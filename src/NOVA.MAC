;***************************************
;**************************** macro list 
;***************************************
;* set_bit              dest,#mask      ;
;* clr_bit              dest,#mask      ;
;* cpl_bit              dest,#mask      ;
;* ld_mm                dst,src         ; memory to memory byte load
;* ldw_mm               dst,src         ; memory to memory word load
;* clrw                 op              ; clear word
;* cpl2_w               wr              ; 2 complement word
;* T0_start                             ; start T0 timer
;* T0_stop                              ; stop T0 timer
;* delay                us              ; ritardo di xxxxx us (fino 65535)
;* sleep                ms              ; ritardo di xxxxx ms (fino 65535)
;* print                where,msg       ; visualizza il messaggio msg
;* relay1               on/off          ; eccita/diseccita il relay 1
;* relay2               on/off          ; eccita/diseccita il relay 2
;* led1                 on/off          ; accende/spegne il led 1
;* led2                 on/off          ; accende/spegne il led 2
;* spi_di                               ; disable SPI interrupt
;* spi_ei                               ; enable SPI interrupt
;* remote_di                            ; disable REMOTE interrupt
;* remote_ei                            ; enable REMOTE interrupt
;* _8880_di                             ; disable MT8880 interrupt
;* _8880_ei                             ; enable MT8880 interrupt
;* byte2bcd             byte,bcd10,bcd1 ; byte to BCD (10,1)
;* bcd2byte             bcd10,bcd1,byte ; BCD (10,1) to byte
;* I2C            opr,slave,addr,lenght ; read/write/verify i2c slaves
;*************************************************************************

;************************             
.macro  set_bit dest,mask                       ;\
   or      dest,#mask                           ; |
.endm                                           ; |
;************************                       ; | Bit macro
.macro  clr_bit dest,mask                       ; | with immediate
   and     dest,#~mask                          ; | mask
.endm                                           ; | 
;************************                       ; | 
.macro  cpl_bit dest,mask                       ; |
   xor     dest,#mask                           ; | 
.endm                                           ;/ 
;************************                       
.macro  ld_mm   dst,src                         ;\  Make a byte memory to
   ld      r0,src                               ; | memory load with immediate
   ld      dst,r0                               ; | address
.endm                                           ;/  
;************************                       
.macro  ldw_mm  dst,src                         ;\  Make a word memory to
   ldw     rr0,src                              ; | memory load with immediate
   ldw     dst,rr0                              ; | address
.endm                                           ;/  
;************************                       
.macro  clrw    op
	xorw    op,op
.endm
;************************                       
.macro  cpl2_w  wr                              ;\
   cpl     r#wr                                 ; |
   cpl     r#(wr+1)                             ; | 2 complememt word
   incw    rr#wr                                ; |
.endm                                           ;/
;************************                       
.macro  T0_start
	pushu   PPR
	spp     #T0D_PG
   or      T_TCR,#cen
	popu    PPR
.endm
;************************
.macro  T0_stop
	pushu   PPR
	spp     #T0D_PG
   and     T_TCR,#~cen
   popu    PPR
.endm
;************************    
.macro  delay   us
	pushuw  rr0
	ldw     rr0,us
	loopw [rr0] {
	   nop
	}
	popuw   rr0
.endm
;************************
.macro  sleep   ms
	pushuw  rr0
   pushuw  rr2
   ldw     rr0,ms
   loopw [rr0] {
      ldw   rr2,#430
      loopw [rr2] {
         nop
      }
   }
   popuw   rr2
	popuw   rr0
.endm
;************************
.macro  print  where,message
	pushuw  rr0
   pushuw  rr2
   pushuw  rr4
   ld      r4,#16
   ldw     rr0,#where
   ldw     rr2,#message
   loop [r4] {
      lddp (rr0)+,(rr2)+
   } 
   popuw   rr4
   popuw   rr2
	popuw   rr0
.endm
;************************
.macro   spi_di       
   and   EIPR,#~ipb0m
   and   EIMR,#~ib0m 
.endm
;************************
.macro   spi_ei
   and   EIPR,#~ipb0m  
	nop
   or    EIMR,#ib0m    
.endm
;************************
.macro   remote_di       
   and   EIPR,#~ipd1m
   and   EIMR,#~id1m 
.endm
;************************
.macro   remote_ei
   and   EIPR,#~ipd1m  
	nop
   or    EIMR,#id1m    
.endm
;************************
.macro   _8880_di       
   and   EIPR,#~ipa1m
   and   EIMR,#~ia1m 
.endm
;************************
.macro   _8880_ei
   and   EIPR,#~ipa1m  
	nop
   or    EIMR,#ia1m    
.endm
;************************
.macro   relay1 status
   pushu r0
   ld    r0,#status
   if [r0 == #0]
   {
      and     P2DR,#~REL1
   } else {
      or      P2DR,#REL1
   }
   popu  r0
.endm
;************************
.macro   relay2 status
   pushu r0
   ld    r0,#status
   if [r0 == #0]
   {
      and     P2DR,#~REL2
   } else {
      or      P2DR,#REL1
   }
   popu  r0
.endm
;************************
.macro   led1 status
   pushu r0
   ld    r0,#status
   if [r0 == #0]
   {
      and     P2DR,#~LED1
   } else {
      or      P5DR,#LED1
   }
   popu  r0
.endm
;************************
.macro   led2 status
   pushu r0
   ld    r0,#status
   if [r0 == #0]
   {
      and     P2DR,#~LED2
   } else {
      or      P5DR,#LED2
   }
   popu  r0
.endm
;************************
.macro byte2bcd byte,bcd10,bcd1
   pushu   r0
   ld      r0,byte
   ld      bcd1,r0
   and     bcd1,#0Fh
   ld      bcd10,r0
   and     bcd10,#0F0h
   swap    bcd10
   popu    r0
.endm
;************************
.macro bcd2byte bcd10,bcd1,byte
   pushu   r0
   ld      r0,bcd10
   swap    r0
   or      r0,bcd1
   ld      byte,r0
   popu    r0
.endm
;************************
.macro I2C op,slave,addr,lenght
   pushu   PPR
   spp     #0
   clr     EIPR
   pushu   EIMR
   clr     EIMR
   pushuw  rr0
   ld      SLAVE_STAT,#SLAVE_READY
   ld      SLAVE_OP,#op
   ld      SLAVE_W,#slave
   ldw     rr0,addr
   ldw     LENGHT,lenght
   ifw [rr0 > #255]                 
   {                                     
      and     r0,#00000111b
      rol     r0
      or      SLAVE_W,r0
   }
   ld      SLAVE_ADDR,r1
   call    i2c_transfer
   waitbit SLAVE_STAT,#SLAVE_READY
   delay   #2300
   popuw   rr0
;   clr     EIPR
;   nop
   popu    EIMR
   popu    PPR
.endm
;************************
.macro bcd2ascii bcd,ascii
   switch [bcd]
   {
      case #0:
            ld      ascii,#48
      case #10:
            ld      ascii,#48
      case #11:         
            ld      ascii,#42
      case #12:         
            ld      ascii,#35
      default:          
            ld      ascii,bcd
            add     ascii,#48
   }
.endm
;************************
.macro zero address,lenght
   pushuw  rr0
   pushuw  rr2
   xor     r0,r0
   ldw     rr2,lenght
   loopw   [rr2]
   {
      ld      address(rr2),r0
   }
   popuw   rr2
   popuw   rr0
.endm
;************************
