;***************************************
;**************************** macro list 
;***************************************
;* set_bit              dest,#mask      ;
;* clr_bit              dest,#mask      ;
;* cpl_bit              dest,#mask      ;
;* ld_mm                dst,src         ; memory to memory byte load
;* ldw_mm               dst,src         ; memory to memory word load
;* clrw                 op              ; clear word
;* cpl2_w               wr              ; 2 complement word
;* T0_start                             ; start T0 timer
;* T0_stop                              ; stop T0 timer
;* rdwr_data_to_SPI                     ; r0->SPI SPI->r0
;* enable_RX_int                        ;
;* disable_RX_int                       ;
;* enable_TX_int                        ;
;* disable_TX_int                       ;
;* delay                us              ; ritardo di xxxxx us (fino 65535)
;* sleep                ms              ; ritardo di xxxxx ms (fino 65535)
;* print                where,msg       ; visualizza il messaggio msg
;* relay1               on/off          ; eccita/diseccita il relay 1
;* relay2               on/off          ; eccita/diseccita il relay 2
;* spi_di                               ; disable SPI interrupt
;* spi_ei                               ; enable SPI interrupt
;* byte2bcd             byte,bcd10,bcd1 ; byte to BCD (10,1)
;* bcd2byte             bcd10,bcd1,byte ; BCD (10,1) to byte
;* i2c            opr,slave,addr,lenght ; read/write/verify i2c slaves
;*************************************************************************

;************************             
.macro  set_bit dest,mask                       ;\
   or      dest,#mask                           ; |
.endm                                           ; |
;************************                       ; | Bit macro
.macro  clr_bit dest,mask                       ; | with immediate
   and     dest,#~mask                          ; | mask
.endm                                           ; | 
;************************                       ; | 
.macro  cpl_bit dest,mask                       ; |
   xor     dest,#mask                           ; | 
.endm                                           ;/ 
;************************                       
.macro  ld_mm   dst,src                         ;\  Make a byte memory to
   ld      r0,src                               ; | memory load with immediate
   ld      dst,r0                               ; | address
.endm                                           ;/  
;************************                       
.macro  ldw_mm  dst,src                         ;\  Make a word memory to
   ldw     rr0,src                              ; | memory load with immediate
   ldw     dst,rr0                              ; | address
.endm                                           ;/  
;************************                       
.macro  clrw    op
	xorw    op,op
.endm
;************************                       
.macro  cpl2_w  wr                              ;\
   cpl     r#wr                                 ; |
   cpl     r#(wr+1)                             ; | 2 complememt word
   incw    rr#wr                                ; |
.endm                                           ;/
;************************                       
.macro  T0_start
	pushu   PPR
	spp     #T0D_PG
   or      T_TCR,#cen
	popu    PPR
.endm
;************************
.macro  T0_stop
	pushu   PPR
	spp     #T0D_PG
   and     T_TCR,#~cen
   popu    PPR
.endm
;************************
.macro  rdwr_data_to_SPI                       
	do {                                    ;\
      tm      SPICR,#10h                   ; | wait SPI empty
	} while [ CLZ ]                         ; |
	ld      SPIDR,r0                        ; | r0 -> SPIDR
	nop                                     ; |
	do {                                    ; |
      tm      SPICR,#10h                   ; | wait SPI empty
	} while [ CLZ ]                         ; | SPIDR -> r0
	ld      r0,SPIDR                        ;/
.endm
;************************    
.macro  enable_RX_int        
	pushu   PPR          
	spp     #SCI1_PG     
	or      S_IMR,#2     
	popu    PPR          
.endm                        
;************************    
.macro  disable_RX_int       
	pushu   PPR          
	spp     #SCI1_PG     
	and     S_IMR,#0FDh  
	popu    PPR          
.endm                        
;************************    
.macro  enable_TX_int        
	pushu   PPR          
	spp     #SCI1_PG     
	or      S_IMR,#1     
	popu    PPR          
.endm                        
;************************    
.macro  disable_TX_int       
	pushu   PPR          
	spp     #SCI1_PG     
	and     S_IMR,#0FEh  
	popu    PPR          
.endm                        
;************************    
.macro  delay   us
	pushuw  rr0
	ldw     rr0,us
	loopw [rr0] {
	   nop
	}
	popuw   rr0
.endm
;************************
.macro  sleep   ms
	pushuw  rr0
   pushuw  rr2
   ldw     rr0,ms
   loopw [rr0] {
      ldw   rr2,#430
      loopw [rr2] {
         nop
      }
   }
   popuw   rr2
	popuw   rr0
.endm
;************************
.macro  print  where,message
	pushuw  rr0
   pushuw  rr2
   pushuw  rr4
   ld      r4,#16
   ldw     rr0,#where
   ldw     rr2,#message
   loop [r4] {
      lddp (rr0)+,(rr2)+
   } 
   popuw   rr4
   popuw   rr2
	popuw   rr0
.endm
;************************
.macro   spi_di       
   and   EIPR,#~ipb0m
   and   EIMR,#~ib0m 
.endm
;************************
.macro   spi_ei
   and   EIPR,#~ipb0m  
	nop
   or    EIMR,#ib0m    
.endm
;************************
.macro   relay1 status
   pushu r0
   ld    r0,#status
   if [r0 == #0]
   {
      clr_bit P5DR,REL1
   } else {
      set_bit P5DR,REL1
   }
   popu  r0
.endm
;************************
.macro   relay2 status
   pushu r0
   ld    r0,#status
   if [r0 == #0]
   {
      clr_bit P5DR,REL2
   } else {
      set_bit P5DR,REL2
   }
   popu  r0
.endm
;************************
.macro byte2bcd byte,bcd10,bcd1
   pushu   r0
   ld      r0,byte
   ld      bcd1,r0
   and     bcd1,#0Fh
   ld      bcd10,r0
   and     bcd10,#0F0h
   swap    bcd10
   popu    r0
.endm
;************************
.macro bcd2byte bcd10,bcd1,byte
   pushu   r0
   ld      r0,bcd10
   swap    r0
   or      r0,bcd1
   ld      byte,r0
   popu    r0
.endm
;************************
.macro i2c op,slave,addr,lenght
   pushuw rr0
   clr     EIPR
   pushu   EIMR
   clr     EIMR
   ld    SLAVE_STAT,#SLAVE_READY
   ld    SLAVE_OP,#op
   ld    SLAVE_W,#slave
   ldw   rr0,addr
   ldw   LENGHT,lenght
;   ifw [rr0 > #255]                 
;   {                                     
;      and   r0,#00000111b
;      rol   r0
;      or    SLAVE_W,r0
;   }
   ld    SLAVE_ADDR,r1
   call  i2c_bus
   waitbit SLAVE_STAT,#SLAVE_READY
   clr     EIPR
   nop
   popu    EIMR
   popuw   rr0
.endm
;************************
.macro bcd2ascii bcd,ascii
   switch [bcd]
   {
      case #0:
            ld      ascii,#48
      case #10:
            ld      ascii,#48
      case #11:         
            ld      ascii,#42
      case #12:         
            ld      ascii,#35
      default:          
            ld      ascii,bcd
            add     ascii,#48
   }
.endm
;************************
