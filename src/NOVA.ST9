;************************************************************************** 
;*                                                                        *
;* FILE NAME:   Nova.st9                                                  *
;*                                                                        *
;* DESCRIPTION: Firmware for TELESOCCORSO                                 *
;*                                                                        *
;* CONTENTS:    * Simbols and numerical equivalences                      * 
;*              * Internal registers variables allocations                * 
;*              * ST9 configuration code                                  *
;*              * MAIN procedure                                          *
;*              * RTC procedure                                           *
;*              * HW related procedure                                    *
;*              * Interrupt service procedures                            *
;*              * Subroutines                                             *
;*              * Static data define                                      *
;*              * Data section define                                     *
;*                                                                        *
;* VERSION                : 0.9.3B                                        *
;*                                                                        *
;*                                                                        *
;* LAST REVISION          : 09/09/97                                      *
;*                                                                        *
;* AUTHOR                 : Andrea Tuccia                                 *
;*                                                                        *
;**************************************************************************

                        .title          "TS firmware"
                        .pl             66      
                        .list           me      
                        .page

                        EMU      =      1

;**************************************************************************
;**************************** Include section *****************************
;**************************************************************************
.nlist             
.include    "..\include\system.inc"    ; System register
.include    "..\include\page_0.inc"    ; Page 0 register
.include    "..\include\io_port.inc"   ; I/O port register
.include    "..\include\mftimer.inc"   ; MF Timer register
.include    "..\include\ad_c.inc"      ; A/D converter register
.include    "..\include\sci.inc"       ; SCI register
.include    "..\include\bitmacro.inc"  ; BIT macros
.list
.include    "nova.mac"
.include    "menu.mac"
.include    "hardware.inc"



;**************************************************************************
;******************** Simbols and numerical equivalences ******************
;**************************************************************************


;***************************************
;********* text section absolute address
;***************************************
IVR_TABLE       = 0                     ; Start of interrupt vector table
SCI_IVR         = 0x40                  ; Start SCI int vector
EXT_IVR         = 0x50                  ; External interrupt base vector
MFT_IVR         = 0xC0                  ; Multifunction timer int vector
START           = 0x100                 ; Start of C startup code
ROMDATA         = 0x3000                ; Static data start
ROMSIZE         = 0x4000-64             ; ROM size minus 64 reserved bytes


;***************************************
;***************** constants declaration
;***************************************
on              = 1             
off             = 0            

;I2C BUS RELATED
E2_SLAVE     == 10100000b           ; EEPROM control byte
RTC_SLAVE    == 11010000b           ; Real Time Clock control byte

READ         == 1                   ; Read mode
WRITE        == 2                   ; Write mode
VERIFY       == 3                   ; Alternate read mode

TRANS_CTRL   == 1                   ; The slave control transferred
TRANS_ADDR   == 2                   ; The slave address transferred
TRANS_DWR    == 3                   ; The data has been transmitted
TRANS_DRD    == 4                   ; The data has been received

READING      == 1                   ; Slave is reading a byte.
VERIFYING    == 2                   ; Slave is reading the current byte.
WRITING      == 3                   ; Slave is programming a byte.
NO_ACK       == 4                   ; Slave has not acknowledged.

SLAVE_READY  == 0x80                ; Slave is ready for a new operation...


;DTMF/LINETONE DEFINES
TONEHIZ         = 0
TONEDIAL        = 1
TONEPBX         = 2
TONEBUSY        = 3
ZERO            = 10

;MENUS/KEYPAD DECLARATION
FORWBACK        = 11
CONFIRM         = 12


;E2PROM MEMORY LOCATIONS
E2_CHECKSUM     = 0
E2_SERIAL       = 2
E2_SETUP        = 8
E2_REMOTE       = 32
E2_NUMERS       = 480
E2_EVENTS       = 608
E2_SIZE         = 2048

;EVENT RELATED DECLARATION
MAXEVENT        = 30
EVSIZE          = 48
EV_DATE         = 0
EV_TIME         = 3
EV_CAUSE        = 4
EV_NUM          = 5
EV_END          = 6
EV_HOW          = 7
EVALARM         = 4
EVREMOTE        = 8
EVTIMEOUT       = 16
EVRING          = 32
EVRESET         = 4
EVDIGIT         = 8
EVEND           = 16

;DIAGNOSTIC ERRORS
DIAG_OK         = 0
DIAG_E2EMPTY    = 1
DIAG_E2FAIL     = 2
DIAG_ROMFAIL    = 4
DIAG_8880FAIL   = 8
DIAG_RTCFAIL    = 16
DIAG_TIMEFAIL   = 32
DIAG_COREFAIL   = 128

;**************************************************************************
;**************** Internal register variable allocations ******************
;**************************************************************************

;**************
;******* Bank D
;**************

;**************
;******* Bank C
;**************

;**************
;******* Bank B             
;**************

;**************
;******* Bank A             
;**************

;**************
;******* Bank 9     
;**************

;**************
;******* Bank 8             
;**************


;**************
;******* Bank 7                         ; Counters/Flags
;**************
IGNORE  := R127                         ; Ignore current outgoing call
RING_C  := R126                         ; Ring glitch counter
RINGS   := R125                         ; Ring counter
RTCFLAG := R124                         ; RTC installed flag
COUNTCLK:= R123                         ; Counterclock register
SWITCH  := R122                         ; Switches status 
ALARM   := R121                         ; Alarm inputs status
TONE_C  := R120                         ; Tone glitch counter
TONE_S  := R119                         ; Tone sampling counter
DIGIT   := R118                         ; Last dialtone received
PHONE   := R117                         ; User phone hook status
CLOCK_C := R116                         ; RTC pause beetween reads
DISPFL  := R115                         ; Display updating flag
DTMF_S  := R114                         ; Sample DTMF when set
;       := R113                         ; 
;       := R112                         ; 
					
        

;**************
;******* Bank 6                         ; All setup parameters must be here
;**************
EVENTS  := R111                         ; Numero totale di eventi (max. 30)
LASTEV  := R110                         ; Puntatore all'ultimo evento
;       := R109
;       := R108 
;       := R107 
;       := R106
;       := R105 
USRDGT  := R104                         ; Cifra per fine messaggio/allarme
PBX     := R103                         ; Ritardo dopo il primo zero per PBX
DECADIC := R102                         ; Abilita la composizione decadica
MAXRING := R101                         ; Numero di squilli per rispondere
CYCLES  := R100                         ; Ripetizioni del cicli di allarme
REPT    := R99                          ; Ripetizioni del numero da chiamare
MAXCONF := R98                          ; Tempo massimo per confermare
MAXRES  := R97                          ; Tempo max. reset chimate uscenti
PAUSE   := R96                          ; Pausa tra una chiamata e l'altra
SETUP_BK:= 96                           ; Bank 6 contiene il setup



;**************
;******* Bank 5                         ; User menu function registers
;**************
;       :=RR94                          ; print.msg2
;       :=RR92                          ; print.msg1
;       :=R91                           ; break.char
;       :=R90                           ; break.pos-1
;       :=R89                           ; break.pos+1
;       :=R88                           ; maxval.prec
;       :=R87                           ; maxval.val
;       :=R86                           ; minval.pos
;       :=R85                           ; maxval.prec
;       :=R84                           ; maxval.val
;       :=R83                           ; maxval.pos
;       :=R82                           ; input.backch
;       :=R81                           ; input.pos+len
;       :=R80                           ; input.pos+1



;**************
;******* Bank 4                         ; I2C bus manager
;**************
TOT_LENGHT := RR78
SLAVE_W    :=  R77                      ; Write slave control byte
SLAVE_R    :=  R76                      ; Read slave control byte
SLAVE_AH   :=  R75
SLAVE_AL   :=  R74
SLAVE_ABS  := RR74                      ; Absolute address in slave mem.
COUNTER    := RR72                      ; Bytes already transferred.
counter    :=  rr8
LENGHT     := RR70                      ; Number of bytes to be transfert.
lenght     :=  rr6
I2C_SLAVE  :=  R69                      ; Slave control byte.
SPI_STAT   :=  R68                      ; SPI transfer status.
SLAVE_STAT :=  R67                      ; Slave status.
SLAVE_OP   :=  R66                      ; Operation to do by the slave.
SLAVE_ADDR :=  R65                      ; Address in the slave memory.
TEMP       :=  R64                      ; Temporary data.
temp       :=  r0


;**************
;******* Bank 3                         ; Timer0 context registers
;**************
;       :=RR62                          ; Don't define!
;       :=RR60
;       :=RR58
;       :=RR56
;       :=RR54
;       :=RR52
;       :=RR50
;       :=RR48



;**************
;******* Bank 2                         ; WatchDog context registers
;**************
;       :=RR46                          ; Don't define!
;       :=RR44
;       :=RR42
;       :=RR40
;       :=RR38
;       :=RR36
;       :=RR34
;       :=RR32



;**************
;******* Bank 1                         ; Free run space
;**************
;       :=RR30                          ; Don't push/pop
;       :=RR28                          
;       :=RR26                          
;       :=RR24
;       :=RR22
;       :=RR20
;       :=RR18
;       :=RR16



;**************************************************************************
;************************ TS INITIALIZATIONS CODE  ************************
;**************************************************************************
                        .text  


;***************************************
;**************** Interrupt vector table
;***************************************


   .org    IVR_TABLE
	.word   st9$entry                       ; Reset interrupt vector:Entry point
	.word   _trap_div0                      ; Divide by 0 interrupt service routine
	.word   _top_level_int                  ; Top Level interrupt service routine
	;***********************        
   .org    SCI_IVR
   .word   _SCI_it_s_rec_err               ; SCI receiver err int service
	.word   _SCI_9th_bit                    ; SCI 9th bit int service
   .word   _SCI_it_receive                 ; SCI RX int service
   .word   _SCI_it_transmit                ; SCI TX int service
	;***********************        
   .org    EXT_IVR
   .word   _WD_int                         ; Interrupt A0 ( External )
   .word   _8880_int                       ; Interrupt A1 ( External )
   .word   _SPI_int                        ; Interrupt B0 ( External )
   .ifc df EMU
   .word   _DUMMY_int                      ; Interrupt B1 ( Emulator )
   .endc
   .ifc ndf EMU
   .word   _REM_int                        ; Interrupt B1 ( External )
   .endc
   .word   _DUMMY_int                      ; Interrupt C0 ( External )
   .word   _DUMMY_int                      ; Interrupt C1 ( External )
   .word   _DUMMY_int                      ; Interrupt D0 ( External )
   .ifc df EMU
   .word   _REM_int                        ; Interrupt D1 ( Emulator )
   .endc
   .ifc ndf EMU
   .word   _DUMMY_int                      ; Interrupt D1 ( External )
   .endc
	;***********************        
   .org    MFT_IVR
   .word   _T0_int_0                       ; Multifunction timer interrupt
   .word   _T0_int_1                       ; Multifunction timer interrupt
   .word   _T0_int_2                       ; Multifunction timer interrupt
   .word   _T0_int_3                       ; Multifunction timer interrupt
	;***********************        



;***************************************
;************ Linker options entry point
;***************************************
                        .org    START
	;***********************        
st9$entryRS::                                   ; Entry point for Separate 
   sdm                                          ; Read Only Environment -iI
	;***********************        
st9$entryR_::                                   ; Entry point for 
   or      FLAGR,#10b                           ; Read Only Environment -I 
   jr      st9$entry_GO                         ; Set user flag:
                                                ; data (ROM) to bss (RAM) copy
	;***********************        
st9$entry_S::                                   ; Entry point for Separate
   sdm                                          ; Address Space -i
	;***********************        
st9$entry__::                                   ; Entry point for 
   and     FLAGR,#~10b                          ; Common Address Space
st9$entry_GO::                                  ;


;***************************************
;********* system register configuration 
;***************************************
	srp     #(14*2)                         ; Set register bank E

	spp     #0                              ; Init page pointer register
   ld      moder,#(sspm | uspm | div2m)    ; Set USP,SSP in int reg - Ck/2
   ld      usplr,#USTACK                   ; Init User stack pointer
   ld      ssplr,#SSTACK                   ; Init System stack pointer
   ld      cicr,#(gcenm | iamm | cplm)     ; CPL=7,enable counter,nested 
   and     flagr,#3                        ; Clr flag register

   srp     #(15*2)                         ; Set bank register F

;***************************************
;**************** I/O port configuration
;***************************************
   spp     #P2C_PG                         ; Port 2 page
   .ifc df EMU       ;
   ld      p2c2r,#11011110b                ;\
   ld      p2c1r,#01111100b                ; | Set port 2
   ld      p2c0r,#11011111b                ;/
   .endc
   .ifc ndf EMU      ;
   ld      p2c2r,#10011110b                ;\
   ld      p2c1r,#11111101b                ; | Set port 2
   ld      p2c0r,#10011110b                ;/
   .endc
	;***********************
   spp     #P3C_PG                         ; Port 3 page
   ld      p3c2r,#11111111b                ;\ 
   ld      p3c1r,#00000000b                ; | Set port 3
   ld      p3c0r,#11111111b                ;/
   ;***********************
   .ifc df EMU
   spp     #P4C_PG                         ; Port 4 page
	ld      p4c2r,#00000000b                ;\ 
	ld      p4c1r,#11110000b                ; | Set port 4
	ld      p4c0r,#00000000b                ;/
   ld      P4DR ,#11111111b                ;
   P0D  =  P4DR
   .endc
   .ifc ndf EMU
   spp     #P0C_PG                         ; Port 0 page
   ld      p0c2r,#00000000b                ;\ 
   ld      p0c1r,#11110000b                ; | Set port 0
   ld      p0c0r,#00000000b                ;/
   ld      P0DR ,#11111111b                ;
   P0D  =  P0DR
   .endc
   ;***********************
   spp     #P5C_PG                         ; Port 5 page
   ld      p5c2r,#00000000b                ;\
   ld      p5c1r,#11110111b                ; | Set port 5
   ld      p5c0r,#00001000b                ;/
   ld      P5DR ,#00000000b                ;
	;***********************
   .ifc df EMU
   spp     #P7C_PG                         ; Port 7 page
   ld      p7c2r,#00100001b                ;\
   ld      p7c1r,#11011110b                ; | Set port 7
   ld      p7c0r,#00100011b                ;/
   ld      P7DR ,#00111111b                ;
   P1D  =  P7DR
   .endc
   .ifc ndf EMU
   spp     #P1C_PG                         ; Port 1 page
   ld      p1c2r,#00001000b                ;\
   ld      p1c1r,#00110111b                ; | Set port 1
   ld      p1c0r,#00001000b                ;/
   ld      P1DR ,#00001111b                ;
   P1D  =  P1DR     
   .endc
   ;***********************


;***************************************
;*************** interupts configuration
;***************************************
   spp     #EXINT_PG                       ; External interrupts page  
   ld      eimr,#00000001b                 ; Unmask interrupts
   .ifc df EMU
   ld      eitr,#10001101b                 ; Set int triggers
   ld      eiplr,#00101101b                ; Interrups priority (D-A-C-B)
   ld      eivr,#01010100b                 ; Set int_vect=5X / NMI
   .endc
   .ifc ndf EMU
   ld      eitr,#00001101b                 ; Set int triggers
   ld      eiplr,#11011000b                ; Interrups priority (A-C-B-D)
   ld      eivr,#01010100b                 ; Set int_vect=5X / NMI
   .endc
   .ifc df EMU
   ld      nicr,#tlnmm                     ; NMI TLI enabled
   .endc
   .ifc ndf EMU
   clr     nicr                            ; NMI TLI disabled
   .endc
	ld      wcr,#01000000b                  ; Disable WatchDog
   clr     eipr                            ; Clear ext pending int.

;***************************************
;******************************* init WD
;***************************************
	spp     #WDT_PG                         ; Set Watch_dog timer page
   ld      wdtpr,#29                       ; 10 usec prescaler
   ldw     wdtr ,#5000                     ; 50 msec counter
   ld      wdtcr,#(stsp | 48)              ; Continuous, timer, start now

;***************************************
;****************************** init SPI
;***************************************
   spp     #SPI_PG                         ; Set SPI page
   ld      spicr,#(bms | SP_128)           ; I2C bus, 100KHz clock


;***************************************
;****************************** init SCI
;***************************************
   spp     #SCI1_PG                        ; Set SCI page register
   ld      s_brghr,#00                     ; Set baud_rate=19.200
   ld      s_imr,#00h                      ; Set int mask register
   ld      s_ivr,#SCI_IVR                  ; SCI interrupt vector
   ld      s_idpr,#00h                     ; Set interrupt priority=2
   ld      s_chcr,#(wl8 | sb10)            ; 8 data, 1 stop, no parity
   ld      s_ccr,#0                        ; 16X, internal baud rate
   clr     s_isr                           ; Clr pending interrupt
   ldw     s_brgr,#39                      ; Set baud_rate=19.200 (24Mhz)


;***************************************
;******************** Serial line enable
;***************************************
;   srp     #0                              ; Set register bank 0
;   ;***********************
;   spp     #SCI1_PG                        ; Set SCI page register
;   ld      S_TXBR,#0AAh                    ; Trasmit dummy char
;   ;***********************
;   delay   #2000                           ; Delay to end tx
;   ;***********************                
;   and     S_ISR,#00000011b                ; Clear pending bit
;   ld      S_CCR,#0x80                     ; Disable loop back mode
;   ld      s_idpr,#00001000b

;**************************************************************************
;************************** TS MAIN PROGRAM *******************************
;**************************************************************************
init::

	srp     #0                              ; Set register bank 0
	spp     #0                              ; Set Page 0

	call    display_init
	call    _8880_init
   call    _1420_init

   led1    off
   led2    off
   backlight off

   clr     EIPR

   ei

diagnose::
   print   #line1, #msg_diag
   call    rom_check
   call    e2_check
   call    rtc_check
   ifbit r0,#DIAG_ROMFAIL
      print   #line2, #msg_romfail
      led2    on
      sleep   #1000
;      halt
   }
   ifbit r0,#DIAG_E2EMPTY
      call    defaults
      ldw     (remote_buffer),#0
      call    remote_save
      call    save_setup
;      jx      progr
   }
   ifbit r0,#DIAG_E2FAIL
      print   #msg_diagfail, #msg_e2fail
      led2    on
      sleep   #1000
      halt
   }
   ifbit r0,#DIAG_RTCFAIL
      print   #line2, #msg_rtcfail
;      led2    on
      sleep   #1000
;      halt
   }
   if [[r0 == #0] || [r0 == #DIAG_RTCFAIL]]
   {        
      print   #line2, #msg_allok
   }
   if [RTCFLAG != #0]
   {
      call    rtc_start
   }
   sleep   #1000
   call    display_bufclr


idle::
   T0_stop
   spp     #0
   _8880_di
   remote_di

   I2C READ,E2_SLAVE,#E2_REMOTE,#2
   ldw     rr0,#remote_buffer
   ldw     rr2,#i2c_buffer
   lddd    (rr0)+,(rr2)+
   lddd    (rr0)+,(rr2)+

   call    load_setup

   ldw     rr0,#frame_buffer            ; loads the frame buffer
   ldw     (rr0),#0                     ; zero the buffer
   ld      ALARM,#0
   ld      HOOK,#0
   ld      SWITCH,#0
   ld      TONE_S,#255
   ld      RING_C,#0
   ld      RINGS,#0
   remote_ei

   backlight off
   led1    off
   relay1  off
   relay2  off
   mute    on
   sleep   #100

   print   #message_ready
   if [RTCFLAG != #0]
   {
      print   #line2, #message_time
   } else {
      print   #line2, #msg_rtcno
   } 
   while [[IGNORE == #1] && [PHONE == #1]]
   {
      call    clock
   }
   ld      IGNORE,#0

main::
   loop {
      ifbit SWITCH, #PROG
         jx       progr
      }
      if [ALARM > #0]
      {
         print    #line2, #message_altrig
         jx       allarme
      }
      if [PHONE != #0]
      {
         jx       outgoing
      }
      ldw    rr0,(frame_buffer)
      ifw [[rr0 == (remote_buffer)] && [rr0 != #0]]
      {
         print    #line2, #message_alrem
         jx       allarme
      }
      if [RINGS >= MAXRING]
      {
         print    #line2, #message_alring
         jx       allarme
      }
      call     clock
   }


allarme::                                      ; inizio ciclo di allarme
   T0_stop
   remote_di
   led1    on                                  ; segnalazione visiva

   print   #line1, #message_alarm
;   call    event_begin                         ; registrazione inizio

   ifbit SWITCH, #RESET                        ; primo reset check
;     call     event_end                        ; registro la fine del ciclo
     jx       annullamento
   }
   relay1  on                                  ; prendo la linea telefonica
   sleep   #1000

   if [RINGS >= MAXRING]                       ; se e' una chiamata entrante
   {
       jx      ingoing                         ; salto la composizione
   }

recycle::
   ld     r2,#0                                ; indice del numero telefonico
   ld     r13,REPT                             ; numero di ripetizioni
   
retry::
   relay1  on                                  ; in caso di telefonate 
   sleep   #1000                               ; successive riprendo la linea

   if [r2 > #8]                                ; se ho finito i numeri
   {
      ld      r2,#0                            ; ricomincio daccapo
      ld      r13,REPT
   } 
   ld      r0,r2
   call    number_read                         ; leggo il numero memorizzato
;   call    event_number                        ; registro il numero chiamato
   dec     r13                                 ; avvenuta ripetizione
   if [r13 == #0]                              ; se ho finito di ripetere
   {
      inc     r2                               ; passo al numero successivo
   }
   if [(number) == #0]                         ; se il numero e' mancante
   {
      jx       retry                           ; salto al successivo
   }

   call    combtel                             ; compongo il numero

   ifbit SWITCH, #RESET                        ; secondo reset check
;     call     event_end                        ; registro la fine del ciclo
     jx       annullamento
   }

   sleep   #2000                               ; attesa di 2 sec. 

   call    _tone_sample                        ; controllo tono della linea
   if [r0 == #TONEBUSY]                        ; se occupato attacco....
   {
      relay1  off                               
      ld      COUNTCLK,PAUSE                   ; faccio una pausa
      call    T0_COUNTER                       ; impostata dall'utente
      while [COUNTCLK != #0]
      {
         ifbit SWITCH, #RESET                  ; durante la pausa c'e'
;            call  event_end                    ; un reset check
            jx    annullamento
         }
      }     
      jx   retry                               ; e poi ricomincio
   }

ingoing::

   ld      r0,#1100b                           ; reimposto l'8880
   call    _8880_ctrl_wr
   ld      r0,#0000b                           
   call    _8880_ctrl_wr

   _8880_ei                                    ; per ricevere i DTMF

   ld      DIGIT,#0
   ld      COUNTCLK,MAXCONF                    ; nel tempo massimo
   call    T0_COUNTER                          ; stabilito dall'utente
   
   loop {                                      ; lancio il messaggio
    
      call    _1420_reset                      ; reset del 1420
      sleep   #100

      call    _1420_play                       ; play del messaggio

                                               ; qui faccio un reset check
      sleep   #10000                           ; durata del messaggio

      call    _1420_stop                       ; fine messaggio

      ifbit SWITCH, #RESET                     ; reset check
;         call     event_end
         jx       annullamento
      }
      if [DIGIT == USRDGT]                     ; mi fermo se ricevo il tono
      {
         break
      }
;      call    _tone_sample
;      if [[COUNTCLK == #0] [r0 == #TONEBUSY]]
      if [COUNTCLK == #0]                      ; ma se e' finito il tempo
      {
         relay1  off                           ; sgancio la linea
         ld      COUNTCLK,PAUSE
         call    T0_COUNTER                    ; e faccio una pausa
         while [COUNTCLK != #0]
         {
            ifbit SWITCH, #RESET               ; durante la quale c'e'
;               call  event_end                 ; un reset check
               jx    annullamento
            }
         }
         jx   retry                            ; poi ricomincio
      }
   }

;   ld      r0,#1000b
;   call    _8880_ctrl_wr
;   ld      r0,#0001b
;   call    _8880_ctrl_wr

   ld      DIGIT,#0
;   ld      COUNTCLK,#
;   call    T0_COUNTER
   mute    off                                 ; attivazione vivavoce

   loop {                                      ; fino alla ricezione 
      if [DIGIT == USRDGT]                     ; di un nuovo tono
      {
         break
      }
;      call    _tone_sample
;      if [r0 == #TONEBUSY]
;      if [[COUNTCLK == #0] [r0 == #TONEBUSY]]
;      {
;         break
;      }
      ifbit SWITCH, #RESET
;         call     event_end
         jx       annullamento
      }
   }
;   call     event_end
   relay1  off
   print   #message_alarm, #message_ok
   sleep   #2000
   jx      idle
   
annullamento::
   print   #message_alarm, #message_break
   sleep   #2000
   jx      idle


outgoing::
   print   #message_cornetta, #message_alzata
   ld      COUNTCLK,MAXRES
   call    T0_COUNTER
   while [COUNTCLK != #0]
   {
      ifbit SWITCH, #RESET
         ld    IGNORE,#1
         jx    idle
      }
      if [PHONE == #0]
      {
         jx    idle
      }
   }
   print   #line2, #message_alout
   relay1  on
   relay2  on
   sleep   #500
   relay1  off
   relay2  off
   sleep   #500
   jx      allarme

;   loop {
;      call    _tone_sample
;      if [r0 == #TONEBUSY]
;      {
;         print    line2, #message_alout
;         jx       allarme
;      }
;      ifbit SWITCH,#RESET
;         ld       IGNORE,#1
;         jx       idle
;      }
;      if [PHONE == #0]
;      {
;         jx       idle
;      }
;   }


progr::

   ld      r0,#1100b
   call    _8880_ctrl_wr
   ld      r0,#0000b
   call    _8880_ctrl_wr

   _8880_ei
   remote_di
   backlight on

   print   #message_progst, #message_tastibegin
   
   relay1  on
   relay2  on
   mute    off

   sleep   #1000
   
   ld      r2,#0
   ld      DIGIT,#0

   ld      r15,#5
   if [RTCFLAG == #0]
   {
      ld      r15,#3
   }
   .menu r15
      .display #0, menu_messaggi,     message_tastipr
      .display #1, menu_numeri,       message_tastipr
      .display #2, menu_telecomando,  message_tastipr
      .display #3, menu_imposta,      message_tastipr   
      .display #4, menu_oradata,      message_tastipr
      .display #5, menu_eventi,       message_tastipr   
      .action  #0
                  call    menu_messages
      }
      .action  #1
                  call    menu_numbers
      }
      .action  #2
                  call    menu_remote
      }
      .action  #3
                  call    menu_setup
      }
      .action  #4
                  call    menu_clock
      }
      .action  #5
                  call    menu_events
      }
   .endmenu
   relay1  off
   relay2  off
   print   #message_fineprog1, #message_fineprog2
   sleep   #1000
   jx      idle


menu_remote::
   pushu   r1 
   pushu   r2
   .menu #2
      .display #0, sub_remote1,       sub_remote2
      .display #1, sub_remcode1,,     remote
      .display #2, menu_preced1,      menu_preced2
      .action  #0
                  print   #sub_remhit1, #sub_remhit2
                  ldw     rr6,#frame_buffer
                  ldw     (rr6),#0
                  ldw     rr8,#200
                  remote_ei
                  loopw [rr8]
                  {
                     sleep   #100
                     ldw     rr6,(frame_buffer)
                     ifw [rr6 != #0]
                     {
                        break
                     }
                     ifnobit SWITCH, #PROG
                        break
                     }
                  }
                  remote_di
                  ifw [rr6 == #0]
                  {
                     print   #sub_remfail1, #sub_remfail2
                     sleep   #2000
                  } else {
                     ldw     rr6,#frame_buffer
                     ldw     rr8,#remote_buffer
                     ldw     (rr8),(rr6)
                     print   #line1, #sub_remok
                     call    remote
                     call    remote_save
                     sleep   #2000
                  }
      }
      .action #1
                     call    remote_enter
      }
      .action #2
                     break
      }
   .endmenu
   popu    r2
   popu    r1
   ret


menu_messages::
   pushu   r1
   pushu   r2
   .menu #2
      .display #0, messaggi_record1,  messaggi_record2
      .display #1, messaggi_play1,    messaggi_play2
      .display #2, menu_preced1,      menu_preced2
      .action  #0
                  call    _1420_reset
                  sleep   #400
                  print   #sub_record1, #sub_record2
                  call    _1420_record
                  sleep   #10000
                  call    _1420_stop
                  print   #sub_recend1, #sub_recend2
                  sleep   #1000
      }
      .action  #1
                  call    _1420_reset
                  sleep   #100
                  print   #sub_play1, #sub_play2
                  call    _1420_play
                  sleep   #10000
                  call    _1420_stop
                  print   #sub_playend1, #sub_playend2
      }
      .action  #2
                  break
      }
   .endmenu
   popu    r2
   popu    r1
   ret


menu_numbers::
   pushu   r1
   pushu   r2
   ld      r0,#1
   .menu #8
      .display #8, menu_preced1,      menu_preced2
      .action  #8
         break
      }
      if [r1 == #CONFIRM]
      {
         call    number_enter
      }
      if [[r2 < #8] && [r2 != r0]]
      {
         ld      r0,r2
         call    number_read
         call    number_show
      }
   .endmenu
   popu    r2
   popu    r1
   ret


menu_setup::
   pushu   r1
   pushu   r2
   .menu #9
      .display #0, sub_T0_1,,         setup_view
      .display #1, sub_T1_1,,         setup_view
      .display #2, sub_T2_1,,         setup_view
      .display #3, sub_C0_1,,         setup_view
      .display #4, sub_C1_1,,         setup_view
      .display #5, sub_C2_1,,         setup_view
      .display #6, sub_selection1,,   setup_view
      .display #7, sub_pbx1,,         setup_view
      .display #8, sub_usrdgt1,,      setup_view
      .display #9, menu_preced1,      menu_preced2
      if [[r1 == #CONFIRM] && [r2 < #9] && [r2 != r0]]
      {
         call    setup_enter
      }
      .action #9
                 break
      }
   .endmenu
   popu    r2
   popu    r1
   ret


menu_clock::
   pushu   r1
   pushu   r2
   .menu #2
      .display #0, sub_time1,,        clock
      .display #1, sub_date1,,        date
      .display #2, menu_preced1,      menu_preced2
      .action #0
                  call time_enter
      }
      .action #1
                  call date_enter
      }
      .action #2
                  break
      }
   .endmenu
   popu    r2
   popu    r1
   ret


menu_events::
   pushu   r1
   pushu   r2
   ld      r0,#1
   ld      r13,EVENTS
   .menu r13
      .display r13, menu_preced1,      menu_preced2
      .action  r13
         break
      }
      if [r1 == #CONFIRM]
      {
         call    event_view
      }
      if [r1 == #1]
      {
         call    event_erase
      }
      if [r2 < r13]
      {
         ld      r0,r2
         di
         aaa::
         call    event_set
         ei
         call    event_show
      }
   .endmenu
   popu    r2
   popu    r1
   ret


;**************************************************************************
;********************** INTERRUPT SERVICE ROUTINES ************************
;**************************************************************************


;***************************************
;******** Multifunction Timer interrupts
;***************************************
_T0_int_0::
   push  PPR
   ;***********************                
   spp     #T0D_PG                         ; Enable Timer0 page
   and     T_FLAGR,#~(ouf | cp0 | cp1)     ; Clear Overflow/Underflow/Capture
   ;***********************
   dec     COUNTCLK                        ; When counter zeroes stop
   if [COUNTCLK == #0]
   {
      and      T_TCR,#~cen                 ; Stop Timer0
   } 
   ;***********************
   pop   PPR
	iret                                    

_T0_int_1::
	iret                                    

_T0_int_2::
   iret                                    

_T0_int_3::
   iret


;***************************************
;**************************** _trap_div0
;***************************************
_trap_div0::                                    ; Divide by 0 interrupt service routine
	ret


;***************************************
;******************* Top level interrupt
;***************************************
_top_level_int::                                ; Top Level interrupt service routine
	iret


;***************************************
;****************** SCI errors interrupt
;***************************************
_SCI_it_s_rec_err::
	iret


;***************************************
;***************** SCI 9th bit interrupt
;***************************************
_SCI_9th_bit::
	iret


;***************************************
;**************** SCI TX empty interrupt
;***************************************
_SCI_it_transmit::
	iret


;***************************************
;********************* SCI RX interrupt
;***************************************
_SCI_it_receive::
	iret


;***************************************
;********************* WD timer int 50ms
;***************************************
_WD_int::
   push    PPR                             ; Save PPR
   pushw   RPP                             ; Save RPP
   srp     #(2*2)                          ; Switch context
   spp     #0
   ;clr     EIPR                            ; clear pending interrupts
   ;nop
   ;pushu   EIMR
   ;clr     EIMR                       
   and     EIPR,#~ipwd                     ; clear pending bit
   ;***********************
   call    display_update                  ; resfresh display
   ;***********************
   ifbit   P3DR,#ALARM1                    ; poll external alarms
      ld      ALARM,#ALARM1
   }
   ifbit   P3DR,#ALARM2
      ld      ALARM,#ALARM2
   }
   ifbit   P3DR,#ALARM3
      ld      ALARM,#ALARM3
   }
   ifbit   P3DR,#RESET                     ; poll user switches
      or      SWITCH,#RESET
   } else {
      and     SWITCH,#~RESET
   }
   ifbit   P3DR,#PROG
      or      SWITCH,#PROG
   } else {
      and     SWITCH,#~PROG
   }
   ifnobit   P5DR,#RING                    ; poll ring detector or
      if [RING_C < #18]
      {
        inc      RING_C
      } else {
        inc      RINGS
        ld       RING_C,#0
      }
   } else {
      ifbit   P3DR,#HOOK                   ; phone hook status
         ld      PHONE,#1
      } else {
         ld      PHONE,#0
      }
   }
   ;***********************
   if [TONE_S < #36]                       ; poll line-tone input to
   {                                       ; calculate a silence/tone ratio
      ld      r0,#200                    
      loop [r0] {
         ld      r1,P2DR
         and     r1,#DTMFCP
         if [r1 == #DTMFCP]
         {
            inc     TONE_C
            break
         }
         nop
         nop
      }
      inc     TONE_S
   }
   ;***********************
   ;spp     #0
   ;clr     EIPR                            ; WD generate spurious
   ;nop
   ;popu    EIMR                            ; re-enable all interrupts
   ;***********************
   popw    RPP                              ; Restore context
   pop     PPR
	iret


;***************************************
;**************************** MT8880 IRQ
;***************************************
_8880_int::
   push    PPR
   pushw   RPP                              
   srp     #(3*2)                           ; switch context
   spp     #0
   and     EIPR,#~ip8880                    ; clear pending bit
   call    _8880_ctrl_rd
   ifbit   r0,#0101b                        ; verify (for spurious)
      call    _8880_data_rd
      ld      DIGIT,r0                      ; valid data in DIGIT
	}
   popw    RPP                              ; restore context
   pop     PPR
	iret


;***************************************
;************************* SPI Interrupt
;***************************************
_SPI_int::
   push    PPR
   pushw   RPP
   srp     #(4*2)
   spp     #0
   if [SPI_STAT == #TRANS_DRD]
   {
      ld    temp,SPIDR         
      ld    i2c_buffer(counter),temp
      incw  counter
      decw  lenght
      if    [SETZ]
      {
         call  GEN_STOP   
         ld    SLAVE_STAT,#SLAVE_READY 
		} else {
         call  GEN_ACK 
         ld    SPI_STAT,#TRANS_DRD
         spp   #0
         ld    temp,#0FFH 
      } 
	} else {
      call  TEST_ACK          
      if [SLAVE_STAT == #NO_ACK]
      { 
         call  GEN_STOP      
         or    SLAVE_STAT,#SLAVE_READY   
		} else {
         switch [SPI_STAT] {
         case  #TRANS_CTRL:
            if [SLAVE_STAT == #VERIFYING]
            {
               ld    SPI_STAT,#TRANS_DRD
               spp   #0
               ld    temp,#0FFH 
				} else {
               ld    SPI_STAT,#TRANS_ADDR
					spp	#0
               ld    temp,SLAVE_ADDR
            }
         case  #TRANS_ADDR:
            if [SLAVE_OP == #READ]
            {
               call  GEN_START   
               ld    SPI_STAT,#TRANS_CTRL
               ld    temp,SLAVE_R
               ld    SLAVE_STAT,#VERIFYING  
				} else {
					spp	#0
               ld    SPI_STAT,#TRANS_DWR
               ld    temp,i2c_buffer(counter)
            } 
         case  #TRANS_DWR:
				spp	#0
            incw  counter
            decw  lenght  
            if    [CLZ]
            {
               ld    temp,i2c_buffer(counter)
            } else {  
               call  GEN_STOP
               or    SLAVE_STAT,#SLAVE_READY   
            } 
         }
      }
   } 
   ld    SPIDR,temp
   popw  RPP
   pop   PPR
	iret


;***************************************
;********************** REMOTE interrupt
;***************************************
_REM_int::
	push    PPR                             ; Save PPR
	pushw   RPP                             ; Save RPP
   srp     #(3*2)                          ; Switch context
   spp     #0
   and     EIPR,#~iprem                    ; clear pending bit
   delay   #30
   ifbit P2DR,#REMOTE                      ; Is here a level 1
      delay   #100
      ifbit P2DR,#REMOTE                   ; after 200 usec
         call    _frame_sample
      }
   }
	popw    RPP                             ; Restore context    
	pop     PPR
	iret                                    


;***************************************
;******** DUMMY interrupt (only returns)
;***************************************
_DUMMY_int::
   iret



;**************************************************************************
;******************************** DISPLAY *********************************       
;**************************************************************************

				    
;***************************************
;************************** init display
;***************************************
display_init::
   ld      P0D,#01001111b                  ; scrittura istruzioni
	;***********************    
	ld      r0,#00110000b                   ;\
	call    _display_nibble_wr              ; |
	delay   #4000                           ; | 
	ld      r0,#00110000b                   ; |
	call    _display_nibble_wr              ; | display software reset
	delay   #100                            ; | 
	ld      r0,#00110000b                   ; |
	call    _display_nibble_wr              ; |
	delay   #100                            ;/
	;***********************
	call    _display_ready
	ld      r0,#00100000b                   
	call    _display_nibble_wr              ; set interface to 4 bit
	;***********************
	call    _display_ready
	ld      r0,#00101000b                   ; set 2 lines, 5*7 font
	call    _display_write
	;***********************
	call    _display_ready
	ld      r0,#00001000b                   ; display off
	call    _display_write
	;***********************
	call    _display_ready
	ld      r0,#00001110b                   ; display on
	call    _display_write
	;***********************
	call    _display_ready
	ld      r0,#00000110b                   ; entry mode set
	call    _display_write
	ret


;***************************************
;************************ display update
;***************************************

display_return::
	call    _display_ready
   ld      P0D,#01001111b                    ; set_dis_inst_wr_mode
   ld      r0,#00000010b                     ; return home
	call    _display_write
	ret

display_bufclr::
	ldw     rr8,#display_buffer
   ld      r10,#32                           ; loop write 32 char
	ld      r11,#00100000b
   loop [r10] {                              ; fill display buffer
      ld      (rr8)+,r11                     ; with spaces
	}
	ret

display_update:
	pushuw  rr0
	pushuw  rr2
	pushuw  rr8
	pushuw  rr10
	;***********************
	call    _display_ready
   ld      P0D,#01001111b                    ; scrittura istruzioni
   ld      r0,#10000000b                     ; first line (set address)
	call    _display_write
	;***********************
	ldw     rr8,#display_buffer
	ld      r10,#16
   loop [r10] {                              ; loop 16 times (a line)
		call    _display_ready
      ld      P0D,#01101111b                 ; scrittura dati
		ld      r0,(rr8)+
		call    _display_write
	}
	;***********************
	call    _display_ready
   ld      P0D,#01001111b                    ; scrittura istruzioni
   ld      r0,#11000000b                     ; second line (set address)
	call    _display_write
	;***********************
	ld      r10,#16
   loop [r10] {                              ; loop 16 times (a line)
		call    _display_ready
      ld      P0D,#01101111b                 ; scrittura dati
		ld      r0,(rr8)+
		call    _display_write
	}
	popuw   rr10
	popuw   rr8
	popuw   rr2
	popuw   rr0
	;*********************** 
	ret

;***************************************
;****************** display nibble write
;***************************************
_display_nibble_wr::
	pushu   PPR
   P1_PAGE
	;***********************
   or      P1D,#ENABLE            ; set E
	;*********************** 
	swap    r0
	and     r0,#00001111b
   ld      r2,P0D
	and     r2,#11110000b             
	or      r0,r2
   ld      P0D,r0                 ; write
	;***********************
   and     P1D,#~ENABLE           ; reset E
	;***********************
	popu    PPR                 
	ret

;***************************************
;******************* display nibble read
;***************************************
;_display_nibble_rd::
;   pushu   PPR
;   P1_PAGE
;   ;***********************
;   or      P1D,#ENABLE            ; set E
;   nop
;   and     P1D,#~ENABLE           ; reset E
;   ;***********************
;   nop
;   ld      r0,P0D                 ; read
;   and     r0,#00001111b
;   swap    r0
;   ;*********************** 
;   popu    PPR                 
;   ret


;***************************************
;******************** display char write
;***************************************
_display_write::
   pushu   r0
   call    _display_nibble_wr
	popu    r0
	swap    r0
	call    _display_nibble_wr
	ret

;***************************************
;******************** display char write
;***************************************
;_display_read::
;   call    _display_nibble_rd
;   ld      r1,r0
;   call    _display_nibble_rd
;   swap    r0
;   or      r1,r0
;   ld      r0,r1
;   ret

;***************************************
;******************** is display ready ?
;***************************************
_display_ready:: 
;   pushu   P0D
;   pushu   PPR
;   P1_PAGE
;   ;***********************
;   ld      P0D,#01011111b          ; modo instruzioni & read
;   ;***********************
;   ld     r2,#0FFh
;   loop [r2] {
;      call    _display_read
;      ifbit   r0,#10000000b        ; controlla il BF
;         break
;      }
;   }
   delay   #20
;   ;***********************
;   popu    PPR
;   popu    P0D
	ret


;**************************************************************************
;******************  Composizione numeri telefonici  **********************
;**************************************************************************
				    
combtel::
   if [DECADIC == #0]
   {
      call    combtel_dtmf
   } else {
      call    combtel_decadic
   }
   ret

;****************************************
;******** Combinatore telefonico decadico
;****************************************
combtel_decadic::
   ldw  rr8,#number
   do {         
	   ld      r11,(rr8)+           ; rr8 contiene i numeri
	   loop [r11] {
         relay1  off       
         sleep   #40               ; da calibrare
         relay1  on
         sleep   #60               ; da calibrare
	   }
      sleep   #500
   } while [(rr8) != #0]
	ret        


;****************************************
;************ Combinatore telefonico DTMF
;****************************************
combtel_dtmf::
   ldw     rr8,#number
   ld      r10,#0
   do {
      ld      r0,#1011b
      call    _8880_ctrl_wr
      ld      r0,#0000b
      call    _8880_ctrl_wr

      ld      r0,(rr8)+
		call    _8880_data_wr
      do {
         call    _8880_ctrl_rd
         and     r0,#0010b
      } while [r0 == #0]
      inc     r10
      if [[(number) == #ZERO] && [PBX != #0] && [r10 == #1]]
      {
         sleep   #800
      }
   } while [(rr8) != #0]
	ret


;**************************************************************************
;**********  MT 8880 (Tranceiver DTMF / Call progress tone)  **************
;**************************************************************************

;***************************************
;*************** initializate the MT8880
;***************************************
_8880_init::
	ld      r0,#0000b
	call    _8880_ctrl_wr
   ld      r0,#1000b
	call    _8880_ctrl_wr
   ld      r0,#0000b
	call    _8880_ctrl_wr
   call    _8880_ctrl_rd
   ret


;***************************************
;********* write to MT8880 data register
;***************************************
;* input: r0 bit3..0
;*        bit 7,,4 must be 0
;***************************************
_8880_data_wr::
   pushu   P0D
   ld      r1,#0                   ; assert data write and CS
   ld      P0D,r1
   or      r1,#O2                  ; 10000000b
   ld      P0D,r1
   or      r0,r1
   ld      P0D,r0
   and     r0,#~O2                 ; 01111111b
   ld      P0D,r0
   delay   #10
   popu    P0D
	ret


;***************************************
;****** write to MT8880 control register
;***************************************
;* input: r0 bit3..0
;*        bit 7,,4 must be 0
;***************************************
_8880_ctrl_wr::
   pushu   P0D
   ld      r1,#RS0                 ; 00100000b  
   ld      P0D,r1
   or      r1,#O2                  ; 10000000b
   ld      P0D,r1
	or      r0,r1
   ld      P0D,r0
   and     r0,#~O2                 ; 01111111b
   ld      P0D,r0
   delay   #10
   popu    P0D
	ret


;***************************************
;************* read MT8880 data register
;***************************************
;* output: r0 bit3..0
;*
;***************************************
_8880_data_rd::
   pushu   P0D
   ld      r1,#(RWN | 15)          ; 00011111b
   ld      P0D,r1
   or      r1,#O2                  ; 10000000b
   ld      P0D,r1
   nop
   ld      r3,P0D
   ld      r0,#~O2                 ; 01111111b
   ld      P0D,r0
   ld      r0,r3
   and     r0,#0xF                 ; 00001111b        
   delay   #10
   popu    P0D
	ret


;***************************************
;********** read MT8880 control register
;***************************************
;* output: r0 bit3..0
;*
;***************************************
_8880_ctrl_rd::
   pushu   P0D
   ld      r1,#(RS0 | RWN | 15)    ; 00111111b  
   ld      P0D,r1
   or      r1,#O2                  ; 10000000b
   ld      P0D,r1
   nop
   ld      r3,P0D
   ld      r0,#~O2                 ; 01111111b
   ld      P0D,r0
	ld      r0,r3           
   delay   #10
   popu    P0D
	ret


;****************************************
;********** put 8880 in POWER DOWN
;****************************************
_8880_pwd::
   push    P0D
   ld      r1,P0D
   and     r1,#~O2                 ; pongo O2  a 0 
   or      r1,#CSN                 ; pongo CS* a 1 
   ld      P0D,r1
   pop     P0D
	ret

;**************************************************************************
;****************** Sezione messaggistica vocale **************************
;**************************************************************************

;****************************************
;************ Inizializza comandi ISD1420
;****************************************
_1420_init::
   pushu   PPR
   and     P5DR ,#~(CUE | CONT)      ; Non definitivo: solo per 1 messaggio
   popu    PPR
   ret

;****************************************
;************ Salta al prossimo messaggio
;****************************************
_1420_cue::
   pushu   PPR
   and         P5DR,#~CUE
   sleep       #100
   or          P5DR,#CUE
   popu    PPR
   ret

;****************************************
;***************** "Riavvolge" i messaggi
;****************************************
_1420_reset::
   pushu   PPR
   and         P5DR,#~CONT
   sleep       #100
   or          P5DR,#CONT
   popu    PPR
   ret

;****************************************
;******************** Inizia a registrare
;****************************************
_1420_record::
   pushu   PPR
   P1_PAGE
   and     P1D,#~RECN
   sleep   #100
   popu    PPR
   ret

;****************************************
;************ Inizia il play dei messaggi
;****************************************
_1420_play::
   pushu   PPR
   P1_PAGE
   and     P1D,#~PLAYLN
   sleep   #100
   popu    PPR
   ret

;****************************************
;************** Ferma il play o il record
;****************************************
_1420_stop::
   pushu   PPR
   P1_PAGE
   or      P1D,#(RECN | PLAYLN)
   sleep   #100
   popu    PPR
   ret


;**************************************************************************
;************************ Toni linea telefonica ***************************
;**************************************************************************

;****************************************
;************** Routine di riconoscimento
;****************************************

_tone_sample::
   spp     #0
   ld      r0,#1010b
   call    _8880_ctrl_wr
   ld      r0,#0000b
   call    _8880_ctrl_wr


   ld      TONE_C,#0
   ld      TONE_S,#0
   sleep   #200
   while [TONE_S < #36]
   {
     nop
   }

   ld r1,TONE_C
   if [[TONE_C > #11] && [TONE_C < #15]]     ; 11-15 
   {
     ld       r0,#TONEDIAL
   }
   if [[TONE_C > #17] && [TONE_C < #22]]     ; 17-22
   {
     ld       r0,#TONEBUSY
   }
   if [TONE_C > #26]                         ; 26+
   {
     ld       r0,#TONEPBX
   }
   if [TONE_C < #6]
   {
     ld       r0,#TONEHIZ
   }

   ld      r0,#1100b
   call    _8880_ctrl_wr
   ld      r0,#0000b
   call    _8880_ctrl_wr

	ret


;**************************************************************************
;***************************** Telecomando ********************************
;**************************************************************************


;****************************************
;*************** Campionamento principale
;****************************************
_frame_sample::
                                           ; time critical section begin
   waitnobit  P2DR,#REMOTE                 ; wait the first 0 level
   ldw        rr0,#frame_buffer            ; loads the frame buffer
	ldw        (rr0),#0                     ; zero the buffer
	ld         r2,#2                        ; 2 samples of 6 bits
	loop [r2] {                             ; 
	   ld         r4,#0                     ; zero the shift register
	   ld         r3,#6                     ; 
	   loop [r3] {                          ; single bit sample loop
	      delay      #320                   ; wait 390uS (to calibrate)
         ifbit P2DR,#REMOTE                ;
            ld         r5,#1               ; if level 1 r5 = 1
         } else {                          ;
            ld         r5,#0               ; else r5 = 0
         }                                 ;
         or         r4,r5                  ; add into shift register
	      rol        r4                     ; and shift left one bit
	      delay      #150                   ; wait 130uS (to calibrate)
	      waitnobit  P2DR,#REMOTE           ; wait for 0
	   }
      ld         (rr0),r4                  ; put shift reg into buffer
      incw       rr0                       ; increment buffer pointer
	}
                                           ; time critical section end
	ret


;***********************************************************************
;************************** Gestione bus i2c ***************************
;***********************************************************************

;****************************************
;*********** I2C bus operations on slaves
;****************************************
_i2c_transfer::
   pushu   PPR                             ; critical section begin
   spp     #0
   clr     EIPR                            
   pushu   EIMR
   clr     EIMR
   spi_di
   ifw [SLAVE_ABS > #255]                 
   {                                     
      and     SLAVE_AL,#00000111b
      rol     SLAVE_AL
      or      SLAVE_W,SLAVE_AL
   }
   ld      SLAVE_ADDR,SLAVE_AH
   ld      SLAVE_R,SLAVE_W                 ; Slave read/write slave
   or      SLAVE_R,#1
   ldw     TOT_LENGHT,LENGHT               ; Save LENGHT before decrement.
   ldw     COUNTER,#0
   ifbit   SLAVE_STAT,#SLAVE_READY         ; Test if bus is free
      switch [SLAVE_OP] {
         case  #READ:
            call     GEN_START             ; SPI and interrupt init
            ld       SPI_STAT,#TRANS_CTRL  ; Slave address
            ld       SLAVE_STAT,#READING   ; Start read condition
            ld       SPIDR,SLAVE_W         ; write mode address
         case  #VERIFY:
            call     GEN_START             ; SPI and interrupt init
            ld       SPI_STAT,#TRANS_CTRL  ; Slave address
            ld       SLAVE_STAT,#VERIFYING ; Start verify condition
            ld       SPIDR,SLAVE_R         ; read mode address
         case  #WRITE:
            call     GEN_START             ; SPI and interrupt init
            ld       SPI_STAT,#TRANS_CTRL  ; Slave address
            ld       SLAVE_STAT,#WRITING   ; Start write condition
            ld       SPIDR,SLAVE_W         ; write mode address
      }
   }

   waitbit SLAVE_STAT,#SLAVE_READY
   delay   #2300
   popu    EIMR
   popu    PPR                             ; critical section end
   ret

;****************************************
;************* START condition generation
;****************************************
GEN_START::
   pushu   PPR
   spp      #0                         ; SPI and ext. ints. in page 0.
   and      SPICR,#~spen               ; Disable SPI -> SDA, SCK in HZ
   and      P2DR,#~SDO                 ; Prepare "0" on output buffer of SDO.
   spp      #P2C_PG
   and      P2C0R,#~SDO                ; SDO line in output -> SDA line = "0".
   delay    #3                         ; Wait for start condition hold time.
   spp      #0
   or       SPICR,#spen                ; Enable SPI.
   nop
   spi_ei                              ; Enable SPI interrupt.
   spp      #P2C_PG
   or       P2C0R,#SDO                 ; SDO line in AF.
   popu     PPR
   ret

;****************************************
;************** STOP condition generation
;****************************************
GEN_STOP::
   pushu   PPR
   spp      #0
   spi_di                              ; Disable SPI interrupt.
   and      P2DR,#~SDO                 ; Prepare "0" on output buffer of SDO.
   spp      #P2C_PG
   and      P2C0R,#~SDO                ; SDO line in output -> SDA line = "0".
   spp      #0 
   and      SPICR,#~spen               ; Disable SPI -> SCK line = "1".
   delay    #3                         ; Wait for stop condition setup.
   spp      #P2C_PG
   or       P2C0R,#SDO                 ; SDO in AF -> SDA line = "1".
   popu     PPR
   ret

;****************************************
;***** ACK pulse generation and force SDA
;****************************************
GEN_ACK::
   pushu   PPR
   and      P2DR,#~SDO                 ; Prepare "0" on output buffer of SDO.
   spp      #P2C_PG                    
   and      P2C0R,#~SDO                ; SDO line in output -> SDA line = "0".
   spp      #0 
   and      SPICR,#~spen               ; Disable SPI -> SCK line = "1".
   delay    #3                         ; Wait for ACK hold time.
   or       SPICR,#spen                ; Enable SPI -> Force SDA and SCK low.
   spp      #P2C_PG
   or       P2C0R,#SDO                 ; SDO line in AF.
   popu     PPR
   ret

;****************************************
;*** ACK pulse generation and slave check
;****************************************
TEST_ACK::
   pushu   PPR
   and     SPICR,#~spen                ; Release SPI lines in disabling it.
   waitbit P2DR,#SCK                   ; Wait for SCK going high.
   ifbit   P2DR,#SDI                   ; Check if receiver has acknowledged.
      ld      SLAVE_STAT,#NO_ACK       ; If no ACK 
   } else {  
      delay   #3                       ; Wait for high period of the clock.
   } 
   or SPICR,#spen                      ; Enable SPI -> Force SDA low.
   popu     PPR
   ret


;**************************************************************************
;********************** Timer per conteggio tempi *************************
;**************************************************************************


;****************************************
;***************** Programmazione timer 0
;****************************************
T0_COUNTER::
   pushu   PPR
	spp     #T0D_PG                         ; Set timer0 data page
   and     T_TCR,  #~cen                   ; Start the timer0

	spp     #T0C_PG                         ; Set timer0 control page
   ld      T0_IVR,#MFT_IVR                 ; Set int vector
   ld      T0_IDCR,#00000001b              ; Set timer0 int level=x

	spp     #T0D_PG                         ; Set timer0 data page
   and     T_TCR,  #~cen                   ; Start the timer0
   ld      T_TCR,  #00000000b              ; Set timer control reg
   ld      T_TMR,  #00000000b              ; Continuous/Retrigger mode
   ld      T_ICR,  #00000000b              ; Set input control reg
   ld      T_IDMR, #10000001b              ; Underflow interrupt
   ld      T_PRSR, #60                     ; 20 usec prescaler value
   ldw     T_REG0R,#50000                  ; 1000 msec counter value
   or      T_TCR,  #cen                    ; Start the timer0
   popu    PPR
   ret

;****************************************
;************** Ritardo di x millisecondi
;****************************************
_msleep::
   pushuw  rr2
   loopw [rr0] {
      ldw   rr2,#430
      loopw [rr2] {
         nop
      }
   }
   popuw   rr2
   ret

;**************************************************************************
;************************* Routines diagnostiche **************************
;**************************************************************************

rom_check::
   ldw     rr0,#0
   ldw     rr2,#0
   ldw     rr4,#0
   di
   ldw     rr8,#(ROMSIZE/2)-3
   spm
   loopw [rr8]
   {
      addw    rr2,(rr4)
      addw    rr4,#2
   }
   ei
checktest::
   ifw [(checksum) != rr2]
   {
      or      r0,#DIAG_ROMFAIL
   }
   sdm
   ret


e2_check::
   ldw     (i2c_buffer),#0
   ldw     (i2c_buffer+2),#0
   I2C READ,E2_SLAVE,#0,#4
pix::
   ifbit SLAVE_STAT, #NO_ACK
      or      r0,#DIAG_E2FAIL
   }
   ifw [[(i2c_buffer) == #0xFFFF] && [(i2c_buffer+2) == #0xFFFF]]
   {
      or      r0,#DIAG_E2EMPTY
   } 
   ret


rtc_check::
   zero    i2c_buffer,#8
   I2C READ,RTC_SLAVE,#0,#8
   ifbit SLAVE_STAT, #NO_ACK
     ld       RTCFLAG,#0
   } else {
     ld       RTCFLAG,#1
   }
   if [(i2c_buffer+7) == #0x1E]
   {
      zero i2c_buffer,#8
      ld   (i2c_buffer+0),#0x0
      ld   (i2c_buffer+1),#0x0
      ld   (i2c_buffer+2),#0x14
      ld   (i2c_buffer+4),#0x01
      ld   (i2c_buffer+5),#0x07
      ld   (i2c_buffer+6),#0x75
      ld   (i2c_buffer+7),#0xE0
      I2C WRITE,RTC_SLAVE,#0,#8
   }
   if [[RTCFLAG == #1] && [(i2c_buffer+7) != #0xE0]]
   {
      or      r0,#DIAG_RTCFAIL
   } 
   ret



;**************************************************************************
;***************************** Routines varie *****************************
;**************************************************************************

defaults::
   zero    i2c_buffer,#16
   ldw     rr2,#0
   ld      r8,#(E2_SIZE / 16)
   loop [r8]
   {
      I2C WRITE,E2_SLAVE,rr2,#16
      addw    rr2,#16
   }
   ld      EVENTS,  #0
   ld      LASTEV,  #0
   ld      USRDGT,  #10
   ld      PBX,     #0
   ld      DECADIC, #0
   ld      MAXRING, #9
   ld      CYCLES,  #1
   ld      REPT,    #1
   ld      MAXCONF, #60
   ld      MAXRES,  #60
   ld      PAUSE,   #60
   ret

load_setup::
   pushuw  rr0
   pushuw  rr2
   pushuw  rr4
   I2C     READ,E2_SLAVE,#E2_SETUP,#16
   ldw     rr0,#i2c_buffer
   ld      r2,#SETUP_BK
   ld      r4,#16
   loop    [r4]
   {
      ld      (r2)+,(rr0)+
   }
   if [EVENTS == #0]
   {
      ld LASTEV,#0
   }
   if [EVENTS == #255]
   {
      ld EVENTS,#0
      ld LASTEV,#0
   }
   popuw   rr0
   popuw   rr2
   popuw   rr4
   ret

save_setup::
   pushuw  rr0
   pushuw  rr2
   pushuw  rr4
   ldw     rr0,#i2c_buffer
   ld      r2,#SETUP_BK
   ld      r4,#16
   loop    [r4]
   {
      ld      (rr0)+,(r2)+
   }
   I2C     WRITE,E2_SLAVE,#E2_SETUP,#16
   popuw   rr0
   popuw   rr2
   popuw   rr4
   ret

remote_save::
   pushuw  rr2
   pushuw  rr4
   ldw     rr2,#i2c_buffer
   ldw     rr4,#remote_buffer
   ldw     (rr2),(rr4)
   I2C WRITE,E2_SLAVE,#E2_REMOTE,#2
   popuw   rr4
   popuw   rr2
   ret

clock::
   if [RTCFLAG == #0]
   {
      ret
   }
   pushuw  rr0
   pushuw  rr2
   pushuw  rr4
   pushuw  rr8
   dec     CLOCK_C
   if [SETZ]
   {
      call    rtc_read
      ld      CLOCK_C,#200
   }
   di
   blank   line2
   ldw     rr6,#line2+12
   ldw     rr4,#rtc_buffer
   ld      r8,#58
   ld      r3,#3
   loop [r3]
   {
      ld    r0,(rr4)
      incw  rr4
      byte2nibble r0,r2,r1
      bcd2ascii r1,r1
      bcd2ascii r2,r2
      ld    -(rr6),r1
      ld    -(rr6),r2
      if [r3 != #1]
      {
         ld    -(rr6),r8
      }
   }
   ei
   popuw   rr8
   popuw   rr4
   popuw   rr2
   popuw   rr0
   ret


date::
   pushuw  rr0
   pushuw  rr2
   pushuw  rr4
   pushuw  rr8
   call    rtc_read
   di
   blank   line2
   ldw     rr6,#line2+12
   ldw     rr4,#rtc_buffer+6
   ld      r8,#47
   ld      r3,#3
   loop [r3]
   {
      ld    r0,(rr4)
      decw  rr4
      byte2nibble r0,r2,r1
      bcd2ascii r1,r1
      bcd2ascii r2,r2
      ld    -(rr6),r1
      ld    -(rr6),r2
      if [[r3 == #2] || [r3 == #3]]
      {
         ld    -(rr6),r8
      }
   }
   ei
   popuw   rr8
   popuw   rr4
   popuw   rr2
   popuw   rr0
   ret


remote::
   pushuw  rr0
   pushuw  rr2
   pushuw  rr4
   pushuw  rr6
   pushuw  rr8
   di
   blank   line2
   ldw     rr6,#line2+2
   ldw     rr4,(remote_buffer)
   ldw     rr8,#remcode_buffer
   ld      r1,#16
   loop [r1] 
   {
      if [[r1 != #16] && [r1 != #8] && [r1 != #9] && [r1 != #1]]
      {
         ld      r2,#48
         ld      r3,#0
         ifbitw  rr4,#1000000000000000b
            ld      r2,#49
            ld      r3,#1
         }
         ld      (rr6)+,r2
         ld      (rr8)+,r3
      }
      rlcw    rr4
   }
   ei
   popuw   rr8
   popuw   rr6
   popuw   rr4
   popuw   rr2
   popuw   rr0
   ret


rtc_read::
   pushuw  rr0
   pushuw  rr2
   pushu   r4
   I2C     READ,RTC_SLAVE,#0,#8
   ldw     rr0,#i2c_buffer
   ldw     rr2,#rtc_buffer
   ld      r4,#8
   ld      r4,#10
   loop [r4] {
      lddd    (rr2)+,(rr0)+
   }
   popu    r4
   popuw   rr2
   popuw   rr0
   ret


rtc_write::
   pushuw  rr0
   pushuw  rr2
   pushu   r4
   ldw     rr0,#i2c_buffer
   ldw     rr2,#rtc_buffer
   ld      r4,#8
   loop [r4] {
      lddd    (rr0)+,(rr2)+
   }
   I2C     WRITE,RTC_SLAVE,#0,#8
   popu    r4
   popuw   rr2
   popuw   rr0
   ret


rtc_start::
   I2C READ,RTC_SLAVE,#0,#1
;   or      (i2c_buffer),#80h
;   I2C WRITE,RTC_SLAVE,#0,#1
   and     (i2c_buffer),#~80h
   I2C WRITE,RTC_SLAVE,#0,#1
   ret


number_read::
   pushu   r1
   pushu   r2
   pushuw  rr12
   zero    number,#16
   ldw     rr2,#8
   mul     rr2,r0
   addw    rr2,#E2_NUMERS
   I2C READ, E2_SLAVE, rr2, #8
   if [(i2c_buffer) != #0]
   {
     ldw     rr12,#0
     ldw     rr4,#0
     loop 
     {
        ld      r3,i2c_buffer(rr12)
        incw    rr12
        byte2nibble r3,r1,r2
        ld      number(rr4),r1
        incw    rr4
        ld      number(rr4),r2
        incw    rr4
        if [[r1 == #0] || [r2 == #0]]
        {
           break
        }
     }
   }
   popuw   rr12
   popu    r2
   popu    r1
   ret


number_write::
   pushu   r1
   pushu   r2
   zero    i2c_buffer,#8
   ldw     rr6,#0
   ldw     rr4,#0
   loop
   {
      ld      r1,number(rr4)
      incw    rr4
      ld      r2,number(rr4)
      incw    rr4
      nibble2byte r1,r2,r3
      ld      i2c_buffer(rr6),r3
      incw    rr6
      if [[r1 == #0] || [r2 == #0]]
      {
         break
      }
   }
   ldw     rr2,#8
   mul     rr2,r0
   addw    rr2,#E2_NUMERS
   I2C WRITE, E2_SLAVE, rr2, #8
   popu    r2
   popu    r1
   ret


number_show::
   pushuw  rr0
   call    display_bufclr
   print   #line1, #numeri_begin
   ldw     rr4,#15
   loopw [rr4] {
      ld      r1,line1(rr4)
      if [r1 == #23h]
      {
         ld    r1,r0
         inc   r1
         bcd2ascii r1,r1
         ld    line1(rr4),r1
      }
   }
   ldw     rr6,#line2
   ldw     rr10,#number
   loop 
   {
      ld      r1,(rr10)+
      bcd2ascii r1,r9
      ld      (rr6)+,r9
      if [r1 == #0]
      {
         ld      r9,#32
         ld      -(rr6),r9
         break
      }
   }
   popuw   rr0
   ret


number_enter::
   pushuw  rr0
   call    number_read
   call    display_bufclr
   print   #line1, #numeri_begin
   ldw     rr4,#line1+11
   ld      r1,r0
   inc     r1
   bcd2ascii r1,r1
   ld      (rr4),r1
   ld      r8,#0
   ldw     rr6,#line2
   ldw     rr10,#number
   if [(number) != #0]
   {
      loop
      {
         ld      r1,(rr10)+
         bcd2ascii r1,r9
         ld      (rr6)+,r9
         inc     r8
         if [r1 == #0]
         {
            ld      r9,#95
            ld      -(rr6),r9
            ld      -(rr10),r1
            dec     r8
            break
         }
      }
   } else {
      ld      r1,#95
      ld      (rr6),r1
   }
   .input 0,16,32
   .endinput
   call    number_write
   popuw   rr0
   ret


time_enter::
   pushuw  rr0
   pushuw  rr2
   call    rtc_read
   ldw     rr4,#rtc_buffer
   ldw     rr10,#time_buffer+6
   ld      r3,#3
   loop [r3] {
      ld      r0,(rr4)
      incw    rr4
      byte2nibble r0,r2,r1
      ld      -(rr10),r1
      ld      -(rr10),r2
   }
   ldw     rr6,#line2
   ldw     rr10,#time_buffer
   ld      r8,#4
   addw    rr6,#4
   ld      r9,#95
   ld      (rr6),r9
   .input  4,8,48
      .maxval   4,2
      .maxval   5,3,2
      .maxval   7,5
      .maxval   10,5
      .break    6,58
      .break    9,58
   .endinput
   ldw     rr4,#rtc_buffer
   ldw     rr10,#time_buffer+6
   ld      r3,#3
   loop [r3] {
      decw    rr10
      ld      r1,(rr10)
      decw    rr10
      ld      r2,(rr10)
      dtmf2bcd r1,r1
      dtmf2bcd r2,r2
      nibble2byte r2,r1,r0
      ld      (rr4),r0
      incw    rr4
   }
   call    rtc_write
   popuw   rr2
   popuw   rr0
   ret


date_enter::
   pushuw  rr0
   pushuw  rr2
   call    rtc_read
   ldw     rr4,#rtc_buffer+6
   ldw     rr10,#date_buffer+6
   ld      r3,#3
   loop [r3] {
      ld      r0,(rr4)
      decw    rr4
      byte2nibble r0,r2,r1
      ld      -(rr10),r1
      ld      -(rr10),r2
   }
   ldw     rr6,#line2
   ldw     rr10,#date_buffer
   ld      r8,#4
   addw    rr6,#4
   ld      r9,#95
   ld      (rr6),r9
   .input  4,8,48
      .maxval   4,3
      .minval   5,1,0
      .maxval   5,1,3
      .maxval   7,1
      .minval   8,1,0
      .maxval   8,2,1
      .break    6,47
      .break    9,47
   .endinput        
   call    rtc_read
   ldw     rr4,#rtc_buffer+6
   ldw     rr10,#date_buffer+6
   ld      r3,#3
   loop [r3] {
      decw    rr10
      ld      r1,(rr10)
      decw    rr10
      ld      r2,(rr10)
      dtmf2bcd r1,r1
      dtmf2bcd r2,r2
      nibble2byte r2,r1,r0
      ld      (rr4),r0
      decw    rr4
   }
   call    rtc_write
   popuw   rr2
   popuw   rr0
   ret


remote_enter::
   call    remote
   pushuw  rr0
   pushuw  rr2
   ldw     rr6,#line2
   ldw     rr10,#remcode_buffer
   ld      r8,#2
   addw    rr6,#2
   ld      r9,#95
   ld      (rr6),r9
   .input  2,12,48
      .maxval   2,1
      .maxval   3,1
      .maxval   4,1
      .maxval   5,1
      .maxval   6,1
      .maxval   7,1
      .maxval   8,1
      .maxval   9,1
      .maxval  10,1
      .maxval  11,1
      .maxval  12,1
      .maxval  13,1
   .endinput
   ldw     rr6,#remcode_buffer
   ldw     rr4,#0
   ld      r1,#16
   loop [r1]
   {
      rlcw    rr4
      andw    rr4,#~1
      if [[r1 != #16] && [r1 != #8] && [r1 != #9] && [r1 != #1]]
      {
         ld      r2,(rr6)
         incw    rr6
         if [r2 == #1]
         {
             orw     rr4,#1   
         }
      }
   }
   ldw     (remote_buffer),rr4
   popuw   rr2
   popuw   rr0
   call    remote_save
   ret


setup_view::
   pushuw  rr0
   pushu   r2
   ld      r4,#SETUP_BK
   add     r4,r2
   di
   switch [r2]
   {
      case #0:
      case #1:
      case #2:
               print   #line2, #sub_times_2
               ldw     rr10,#tempinput
               ldw     rr6,#line2+3
               ld      r3,(r4)

;               byte2nibble r3,r2,r1
               byte2bcd r3,r2,r1

               ld      (rr10)+,r2
               ld      (rr10),r1
               bcd2ascii r2,r2
               bcd2ascii r1,r1
               ld      (rr6)+,r2
               ld      (rr6),r1



      case #3:
      case #4:
               print   #line2, #sub_turns_2
               ldw     rr10,#tempinput
               ldw     rr6,#line2+4
               ld      r1,(r4)
               bcd2ascii r1,r1
               ld      (rr6),r1
      case #5:
               print   #line2, #sub_C2_2
               ldw     rr10,#tempinput
               ldw     rr6,#line2+4
               ld      r1,(r4)
               bcd2ascii r1,r1
               ld      (rr6),r1
      case #6:
      case #7:
               print   #line2, #sub_yesno2
               ldw     rr10,#tempinput
               ldw     rr6,#line2+7
               ld      r1,(r4)
               bcd2ascii r1,r1
               ld      (rr6),r1
      case #8:
               print   #line2, #sub_usrdgt2
               ldw     rr10,#tempinput
               ldw     rr6,#line2+13
               ld      r1,(r4)
               bcd2ascii r1,r1
               ld      (rr6),r1
   }
   ei
   popu    r2
   popuw   rr0
   ret


setup_enter::
   pushuw  rr0
   pushu   r2
   ld      r4,#SETUP_BK
   add     r4,r2
   switch [r2]
   {
      case #0:
      case #1:
      case #2:
               ldw     rr10,#tempinput
               ldw     rr6,#line2+3
               ld      r3,(r4)
;               byte2nibble r3,r2,r1
               byte2bcd r3,r2,r1
               ld      (rr10)+,r2
               ld      (rr10),r1
               bcd2ascii r2,r2
               bcd2ascii r1,r1
               ld      (rr6)+,r2
               ld      (rr6),r1
               ldw     rr10,#tempinput
               ldw     rr6,#line2+3
               ld      r8,#3
               ld      r9,#95
               ld      (rr6),r9
               .input  3,2,32
                  .minval 3,1
               .endinput
               ldw     rr10,#tempinput
               ld      r2,(rr10)+
               ld      r1,(rr10)
               dtmf2bcd r1,r1
               dtmf2bcd r2,r2
;               nibble2byte r2,r1,r3
               bcd2byte r2,r1,r3
               ld      (r4),r3
      case #3:
      case #4:
      case #5:
               ldw     rr10,#tempinput
               ldw     rr6,#line2+4
               ld      r1,(r4)
               bcd2ascii r1,r1
               ld      (rr6),r1
               ldw     rr10,#tempinput
               ldw     rr6,#line2+4
               ld      r8,#4
               ld      r9,#95
               ld      (rr6),r9
               .input  4,1,32
                  .minval 4,1
               .endinput
               ldw     rr10,#tempinput
               ld      r1,(rr10)
               dtmf2bcd r1,r1
               ld      (r4),r1
      case #6:
      case #7:
               ldw     rr10,#tempinput
               ldw     rr6,#line2+7
               ld      r1,(r4)
               bcd2ascii r1,r1
               ld      (rr6),r1
               ldw     rr10,#tempinput
               ldw     rr6,#line2+7
               ld      r8,#7
               ld      r9,#95
               ld      (rr6),r9
               .input  7,1,32
                  .maxval 7,1
               .endinput
               ldw     rr10,#tempinput
               ld      r1,(rr10)
               dtmf2bcd r1,r1
               ld      (r4),r1
      case #8:
               ldw     rr10,#tempinput
               ldw     rr6,#line2+13
               ld      r1,(r4)
               bcd2ascii r1,r1
               ld      (rr6),r1
               ldw     rr10,#tempinput
               ldw     rr6,#line2+13
               ld      r8,#13
               ld      r9,#95
               ld      (rr6),r9
               .input  13,1,32
               .endinput
               ldw     rr10,#tempinput
               ld      (r4)+,(rr10)+
   }
   call    save_setup
   popu    r2
   popuw   rr0
   ret


event_set::
   di
   pushu   r1
   pushu   r2
   ld      r4,LASTEV
   sub     r4,r0
   if [r4 < #0]
   {
;       inc    r4
       add    r4,EVENTS
   }
   ldw     rr8,#EVSIZE
   mul     rr8,r4
   ldw     rr2,#E2_EVENTS
   addw    rr8,rr2
   popu    r2
   popu    r1
   ei
   ret


event_show::
   pushuw  rr0
   pushuw  rr2
   pushu   r6
   I2C  READ,E2_SLAVE,rr8,#3
   di
   print   #line1, #event_num
   ldw     rr4,#line1+11
   ld      r1,EVENTS
   sub     r1,r0
   byte2bcd r1,r3,r2
   bcd2ascii r2,r2
   bcd2ascii r3,r3
   if [r3 == #48]
   {
      ld      r3,#32
   }
   ld      (rr4),r3
   incw    rr4
   ld      (rr4),r2
   ei
   blank   line2
   ldw     rr6,#line2+12
   ldw     rr4,#i2c_buffer
   ld      r8,#47
   ld      r3,#3
   loop [r3]
   {
      ld    r0,(rr4)
      incw  rr4
      byte2nibble r0,r2,r1
      bcd2ascii r1,r1
      bcd2ascii r2,r2
      ld    -(rr6),r1
      ld    -(rr6),r2
      if [[r3 == #2] || [r3 == #3]]
      {
         ld    -(rr6),r8
      }
   }
   popu    r6
   popuw   rr2
   popuw   rr0
   ret

event_view::
   pushuw  rr0
   pushu   r2
   .menu #3
      .display #3, menu_preced1,      menu_preced2
      .action #3
                   break
      }
      pushu  r2
      switch [r2]
      {
         case #0:
                   ldw    rr10,rr8
                   addw   rr10,#3
                   I2C READ,E2_SLAVE,rr10,#4
                   di
                   print   #line1,#event_begin1
                   ldw     rr6,#line1+16
                   ldw     rr4,#i2c_buffer
                   ld      r8,#58
                   ld      r3,#3  
                   loop [r3]
                   {
                      ld    r0,(rr4)
                      incw  rr4
                      byte2nibble r0,r2,r1
                      bcd2ascii r1,r1
                      bcd2ascii r2,r2
                      ld    -(rr6),r1
                      ld    -(rr6),r2
                      if [[r3 == #2] || [r3 == #3]]
                      {               
                         ld    -(rr6),r8
                      }
                   }
                   ei
                   if [(i2c_buffer+4) == #EVREMOTE]
                   {
                      ldw    rr6,#event_remote
                   } else {
;                   if [(i2c_buffer+4) == #EVALARM]
;                   {
                      ldw    rr6,#event_alarm
                   }
                   print  #line2,rr6
         case #1:
                   ldw    rr10,rr8
                   addw   rr10,#8
                   I2C READ,E2_SLAVE,rr10,#4
                   di
                   print   #line1,#event_num1
                   ldw     rr6,#line1+15
                   ld      r1,(i2c_buffer)
                   inc     r1
                   bcd2ascii r1,r1
                   ld      (rr6),r1
                   print   #line2,#event_num2
                   ldw     rr6,#line2+16
                   ldw     rr4,#i2c_buffer+1
                   ld      r8,#58
                   ld      r3,#3  
                   loop [r3]
                   {
                      ld    r0,(rr4)
                      incw  rr4
                      byte2nibble r0,r2,r1
                      bcd2ascii r1,r1
                      bcd2ascii r2,r2
                      ld    -(rr6),r1
                      ld    -(rr6),r2
                      if [[r3 == #2] || [r3 == #3]]
                      {               
                         ld    -(rr6),r8
                      }
                   }
                   ei
         case #2:
                   ldw    rr10,rr8
                   addw   rr10,#12
                   I2C READ,E2_SLAVE,rr10,#4
                   di
                   print   #line1,#event_end1
                   ldw     rr6,#line1+16
                   ldw     rr4,#i2c_buffer
                   ld      r8,#58
                   ld      r3,#3  
                   loop [r3]
                   {
                      ld    r0,(rr4)
                      incw  rr4
                      byte2nibble r0,r2,r1
                      bcd2ascii r1,r1
                      bcd2ascii r2,r2
                      ld    -(rr6),r1
                      ld    -(rr6),r2
                      if [[r3 == #2] || [r3 == #3]]
                      {               
                         ld    -(rr6),r8
                      }
                   }
                   ei
                   if [(i2c_buffer+4) == #EVRESET]
                   {
                      ldw    rr6,#event_reset
                   } else {
;                   if [(i2c_buffer+4) == #EVDIGIT]
;                   {
                      ldw    rr6,#event_digit
                   }
                   print   #line2,rr6
      }
      popu   r2
   .endmenu
   popu    r2
   popuw   rr0
   ret

event_erase::
   dec     LASTEV
   if [EVENTS < #MAXEVENT]
   {
      dec     EVENTS
   }
   if [EVENTS <= #0]
   {
      ld      EVENTS,#0
      ld      LASTEV,#0
   }
   if [LASTEV < #0]
   {
      ld      LASTEV,EVENTS ; (or #MAXEVENT-1)
      dec     LASTEV
   }
   call    save_setup
   ret

event_begin::
   if [RTCFLAG == #0]
   {
      ret
   }
   pushu   r0
   call    rtc_read
   ldw     rr6,#i2c_buffer
   ldw     rr2,#rtc_buffer+4
   lddd    (rr6)+,(rr2)+
   lddd    (rr6)+,(rr2)+
   lddd    (rr6)+,(rr2)+
   ldw     rr2,#rtc_buffer
   lddd    (rr6)+,(rr2)+
   lddd    (rr6)+,(rr2)+
   lddd    (rr6)+,(rr2)+
   if [ALARM != #0]
   {
      ld      (rr6),#EVALARM
   } else {
      ld      (rr6),#EVREMOTE
   }
   ld      r0,#0
   call    event_set
   I2C WRITE,E2_SLAVE,rr8,#7
   popu    r0
   ret

event_number::
   if [RTCFLAG == #0]
   {
      ret
   }
   pushu   r0
   call    rtc_read
   ldw     rr6,#i2c_buffer
   ld      (rr6),r0
   incw    rr6
   ldw     rr2,#rtc_buffer
   lddd    (rr6)+,(rr2)+
   lddd    (rr6)+,(rr2)+
   lddd    (rr6)+,(rr2)+
   ld      r0,#0
   call    event_set
   addw    rr8,#8
   I2C WRITE,E2_SLAVE,rr8,#4
   popu    r0
   ret

event_replay::
   if [RTCFLAG == #0]
   {
      ret
   }
   pushu   r0
   call    rtc_read
   ldw     rr6,#i2c_buffer
   ld      (rr6),r0
   incw    rr6
   ldw     rr2,#rtc_buffer
   lddd    (rr6)+,(rr2)+
   lddd    (rr6)+,(rr2)+
   lddd    (rr6)+,(rr2)+
   ld      r0,#0
   call    event_set
   addw    rr8,#8
   I2C WRITE,E2_SLAVE,rr8,#4
   popu    r0
   ret

event_end::
   if [RTCFLAG == #0]
   {
      ret
   }
   pushu   r0
   call    rtc_read
   ldw     rr6,#i2c_buffer
   ldw     rr2,#rtc_buffer
   lddd    (rr6)+,(rr2)+
   lddd    (rr6)+,(rr2)+
   lddd    (rr6)+,(rr2)+
   ifbit SWITCH,#RESET
      ld      (rr6),#EVRESET
   } else {
      ld      (rr6),#EVDIGIT
   }
   ld      r0,#0
   call    event_set
   addw    rr8,#12
   I2C WRITE,E2_SLAVE,rr8,#4
   inc     EVENTS
   if [EVENTS > #1]
   {
      inc     LASTEV
   }
   if [EVENTS > #MAXEVENT]
   {
      ld      EVENTS,#MAXEVENT
   }
   if [LASTEV >= EVENTS]
   {
      ld      LASTEV,#0
   }
   call    save_setup
   popu    r0
   ret


;**************************************************************************
;********************** Funzioni relative ai munu *************************
;**************************************************************************

_endinput::
         if [[r1 != #0] && [r1 <= #10] && [r8 < R81]]
         {
            bcd2ascii  r1,r9
            ld      (rr6)+,r9
            ld      (rr10)+,r1
            ld      r9,#95
            ld      (rr6),r9
            inc     r8
            clr     r1
         }
         if [[r1 == #FORWBACK] && [r8 == R81]]
         {
            ld      r9,#32
            ld      (rr6),r9
            decw    rr10
            ld      r9,#95
            ld      -(rr6),r9
            dec     r8
            clr     r1
         }
         if [[r1 == #FORWBACK] && [r8 >= R80]] 
         {
            if [R82 == #32]
            {
               ld      r1,#0
               ld      -(rr10),r1
               ld      r9,R82
            } else {
               ld      R82,(rr10)
               bcd2ascii R82,r9
               decw    rr10 
            }
            ld      (rr6),r9
            ld      r9,#95
            ld      -(rr6),r9
            dec     r8
            clr     r1
         }
         if [[r1 == #CONFIRM] && [r8 == R81]]
         {
            ld      r9,#32
            ld      (rr6),r9
            ld      r1,#0xFF         ; do a forward break
         }
         if [r1 == #CONFIRM]
         {
            ld      R82,(rr10)
            if [R82 == #0]
            {
               ld      r9,#32
            } else {
               bcd2ascii R82,r9
            }
            ld      (rr6),r9
            ld      r1,#0xFF         ; do a forward break
         }
         ret


_break::
         if [[r1 != #0] && [r1 <= #10] && [r8 == R90]]
         {
            bcd2ascii  r1,r9
            ld      (rr6)+,r9
            ld      (rr10)+,r1
            ld      r9,R91
            ld      (rr6)+,r9
            ld      r9,#95
            ld      (rr6),r9
            inc     r8
            inc     r8
            clr     r1
         }
         if [[r1 == #FORWBACK] && [r8 == R89]]
         {
            if [R82 == #32]
            {
               ld      r1,#0
               ld      -(rr10),r1
               ld      r9,R82
            } else {
               ld      R82,(rr10)
               bcd2ascii R82,r9
               decw    rr10 
            }
            ld      (rr6),r9
            ld      r9,R91 
            ld      -(rr6),r9
            dec     r8
            ld      r9,#95
            ld      -(rr6),r9
            dec     r8
            clr     r1
         }
         ret

_minval::
         if [R88 == #0xFF]
         {
            if [[r1 == #10] && [r8 == R86]]
            {
               clr     r1
            }
            if [[r1 < R87] && [r1 < #10] && [r8 == R86]]
            {
               clr     r1
            }
         } else {
            ld      r9,-(rr10)
            dtmf2bcd r9,r9
            if [[r9 <= R88] && [r1 == #10] && [r8 == R86]]
            {
               clr     r1
            }
            if [[r9 <= R88] && [r1 < R87] && [r1 < #10] && [r8 == R86]]
            {
               clr     r1
            }
            incw    rr10
         }
         ret

_maxval::
         if [R85 == #0xFF]
         {
            if [[r1 > R84] && [r1 < #10] && [r8 == R83]]
            {
               clr     r1
            }
         } else {
            ld      r9,-(rr10)
            if [[r9 < #10] && [r9 >= R85] && [r1 > R84] && [r1 < #10] && [r8 == R83]]
            {
               clr     r1
            }
            incw    rr10
         }
         ret

_print::
   pushuw  rr0
   pushuw  rr2
   pushu   r4
   ifw [[RR92 == #line1] || [RR92 == #line2]]
   {
      ld      r4,#16
      ldw     rr0,RR92
      ldw     rr2,RR94
      loop [r4] {
         lddp (rr0)+,(rr2)+
      }
   }
   ifw [[RR92 != #line1] && [RR92 != #line2]]
   {
      ld      r4,#16
      ldw     rr0,#line1
      ldw     rr2,RR92
      loop [r4] {
         lddp (rr0)+,(rr2)+
      }
      ifw [RR94 != #0]
      {
         ld      r4,#16
         ldw     rr0,#line2
         ldw     rr2,RR94
         loop [r4] {
            lddp (rr0)+,(rr2)+
         }
      }
   }
   popu    r4
   popuw   rr2
   popuw   rr0
   ret

;**************************************************************************
;************************** Dati statici in rom ***************************
;**************************************************************************

;                        .org    ROMDATA
id::                    .ascii  "FW 0.93B Tuccia (C) 1997"

;****************************************
;**************** Messaggi per il display
;****************************************

message_open::          .ascii  "    PT117/96    "
message_name::          .ascii  "Nova Elettra srl"
msg_diagok::            .ascii  "Hard Ok  Soft Ok"
msg_diagfail::          .ascii  "Rilevato guasto:"
message_ok::            .ascii  "   INOLTRATO    "
message_ready::         .ascii  "Telesoccorso DGE"
message_time::          .ascii  "    ##:##:##    "
message_alarm::         .ascii  "Allarme in corso"
message_alrem::         .ascii  "dal telecomando!"
message_alring::        .ascii  "chiamata entran."
message_altrig::        .ascii  "  dal pulsante  "
message_alout::         .ascii  "numero non comp."
message_break::         .ascii  "   ANNULLATO    "
message_attendere::     .ascii  "attendere prego."

msg_diag::              .ascii  "  AUTODIAGNOSI  "
msg_allok::             .ascii  "Hard:Ok  Soft:Ok"
msg_romfail::           .ascii  "Checksum errato!"
msg_romok::             .ascii  "Checksum ROM: Ok"
msg_e2fail::            .ascii  "E2 non risponde!"
msg_e2ok::              .ascii  "Checksum E2:  Ok"
msg_empty1::            .ascii  "Prima accensione"
msg_empty2::            .ascii  "caricato default"
msg_rtcfail::           .ascii  "RTC non rilevato"
msg_rtcok::             .ascii  "Checksum RTC: Ok"
msg_rtcno::             .ascii  "(no reg. eventi)"
msg_8880fail::          .ascii  "Registri MT8880!"
msg_8880ok::            .ascii  "MT8880 Regs:  Ok"

message_call::          .ascii  "Composizione del"
message_noresp::        .ascii  "  Non risponde  "
message_resp::          .ascii  "Risponde il num."
                                   
message_progst::        .ascii  " Programmazione "
message_tastipr::       .ascii  " *~  # Conferma "
message_tastibegin::    .ascii  "Alzare cornetta!"
message_tastiend1::     .ascii  "    Alla fine   "
message_tastiend2::     .ascii  "  riagganciare. "
message_fineprog1::     .ascii  " Programmazione "
message_fineprog2::     .ascii  "   terminata.   "
menu_messaggi::         .ascii  "    Messaggi   ~"
menu_numeri::           .ascii  "  Numeri Tel. ~"
menu_telecomando::      .ascii  " Telecomando  ~"
menu_imposta::          .ascii  " Impostazioni ~"
menu_oradata::          .ascii  "  Ora / Data  ~"
menu_eventi::           .ascii  "Registro eventi"
sub_notavail1::         .ascii  "Non disponibile!"
sub_notavail2::         .ascii  " *             "

messaggi_record1::      .ascii  "    Registra   ~"
messaggi_record2::      .ascii  " *~   # Inizia  "
messaggi_play1::        .ascii  "  Riascolta   ~"
messaggi_play2::        .ascii  " *~   # Inizia  "
sub_record1::           .ascii  "  Parlare nel   "
sub_record2::           .ascii  " microfono....  "
sub_recend1::           .ascii  "   Messaggio    "
sub_recend2::           .ascii  "  registrato.   "
sub_play1::             .ascii  "   Ascoltare    "
sub_play2::             .ascii  " il messaggio..."
sub_playend1::          .ascii  "     Fine       "
sub_playend2::          .ascii  "   messaggio.   "
messaggi_alarm::        .ascii  "Mess. Allarme #~"

sub_numeri1::           .ascii  "   Numeri Tel.  "
sub_numeri2::           .ascii  " *  # Conferma "

sub_remote1::           .ascii  "   Aquisisci   ~"
sub_remote2::           .ascii  " *~    # Inizia "
sub_remcode1::          .ascii  " Imposta man. ~"
sub_remcode2::          .ascii  "  ############  "

sub_remhit1::           .ascii  "Premere il tasto"
sub_remhit2::           .ascii  "del telecomando!"
sub_remok::             .ascii  "Codice aquisito:"
sub_remfail1::          .ascii  "  Telecomando   "
sub_remfail2::          .ascii  " NON AQUISITO!  "

sub_time1::             .ascii  "  Cambio ORA:  ~"
sub_time2::             .ascii  "    ##:##:##    " 
sub_date1::             .ascii  "  Cambio DATA: ~"
sub_date2::             .ascii  "   ##/##/####   " 

sub_T0_1::              .ascii  "Pausa tra telef:" 
sub_T1_1::              .ascii  "Tempo max reset:" 
sub_T2_1::              .ascii  "Tempo conferma: " 
sub_times_2::           .ascii  "   ## secondi   "
sub_C0_1::              .ascii  "Ripetiz. numeri:" 
sub_turns_2::           .ascii  "    # volte     "  
sub_C1_1::              .ascii  "Ripetiz. ciclo: " 
sub_C2_1::              .ascii  "Risposta dopo:  " 
sub_C2_2::              .ascii  "    # squilli   "  
sub_selection1::        .ascii  "Selez. decadica:"
sub_yesno2::            .ascii  "       #        "
sub_pbx1::              .ascii  "Collegato a PBX:"
sub_usrdgt1::           .ascii  "Fine allarme    "
sub_usrdgt2::           .ascii  "con numero:  #  "

sub_tempi1::            .ascii  "    Tempi     ~"
sub_tempi2::            .ascii  " *             "
sub_riservato1::        .ascii  "  Riservato    "
sub_riservato2::        .ascii  " *             "
numeri_begin::          .ascii  "   Numero  #:   "
numeri_absent::         .ascii  "Non programmato."
menu_preced1::          .ascii  "   Ritorna al   "
menu_preced2::          .ascii  "menu precedente."

message_cornetta::      .ascii  "Cornetta telef. "
message_abbassata::     .ascii  "   ABBASSATA    "
message_alzata::        .ascii  "     ALZATA     "

malvenuto::             .ascii  "Guarda i numeri:"
telesoccorso::          .ascii  "Il telesoccorso:"
telecomando::           .ascii  "Il telecomando: "

msgtony::               .ascii  "Linea telefonica"
msgoccupato::           .ascii  "    OCCUPATA    "
msglibero::             .ascii  "     LIBERA     "
msgpbx::                .ascii  "   PBX LIBERO   "
msghiz::                .ascii  " ALTA IMPEDENZA "

event_num::             .ascii  "   Evento  ##:  "
event_date::            .ascii  "    ##/##/##    "

event_begin1::          .ascii  "Inizio: ##:##:##"
event_remote::          .ascii  "con telecomando "
event_alarm::           .ascii  "con allarme est."

event_end1::            .ascii  "Fine:   ##:##:##"
event_reset::           .ascii  " con reset man. "
event_digit::           .ascii  "con reset remot."

event_num1::            .ascii  "Chiamata del N.#"
event_num2::            .ascii  "alle:   ##:##:##"

;**************************************************************************
;************************* Fine ROM - Checksum ****************************
;**************************************************************************

                        .org    (ROMSIZE - 8)
pattern::               .byte   055h,0AAh
serial::                .byte   1,0,0,0
checksum::              .byte   0,0


;**************************************************************************
;****************** Definizione dei dati dinamici in RAM ******************
;**************************************************************************
    
                        .data
                        .org    DATA

frame_buffer::          .blkb   2               ; format: 0xxxxxx00xxxxxx0

remote_buffer::         .blkb   2               ; format: 0xxxxxx00xxxxxx0

number::                .blkb   20              ; current telefonic number

i2c_buffer::            .blkb   16              ; buffer for i2c bus

rtc_buffer::            .blkb   8               ; rtc time/date buffer

time_buffer::           .blkb   6               ; entered time (bcd)
date_buffer::           .blkb   8               ; entered date (bcd)
remcode_buffer::        .blkb   12              ; remote code buffer (bcd)

display_buffer::
line1::                 .blkb   16              ; display buffer of 32 char
line2::                 .blkb   16

tempinput::             .blkb   4
