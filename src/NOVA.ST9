;************************************************************************** 
;*                                                                        *
;* FILE NAME:   Nova.st9                                                  *
;*                                                                        *
;* DESCRIPTION: Firmware for TELESOCCORSO                                 *
;*                                                                        *
;* CONTENTS:    * Simbols and numerical equivalences                      * 
;*              * Internal registers variables allocations                * 
;*              * ST9 configuration code                                  *
;*              * MAIN procedure                                          *
;*              * RTC procedure                                           *
;*              * HW related procedure                                    *
;*              * Interrupt service procedures                            *
;*              * Subroutines                                             *
;*              * Static data define                                      *
;*              * Data section define                                     *
;*                                                                        *
;* VERSION                : 0.5.0                                         *
;*                                                                        *
;*                                                                        *
;* LAST REVISION          : 18/06/97                                      *
;*                                                                        *
;* AUTHOR                 : Andrea Tuccia                                 *
;*                                                                        *
;**************************************************************************




.title          "TS firmware"
.pl             66                      ; number of lines per page
.list           me                      ; enable macro expansion control
.page




;***************************************
;*********************** Include section
;***************************************
;*
;* The following section include the standard 
;* symbols for the ST9040
;*
;***************************************
.nlist             
.include    "\st9\include\system.inc"    ; System register
.include    "\st9\include\page_0.inc"    ; Page 0 register
.include    "\st9\include\io_port.inc"   ; I/O port register
.include    "\st9\include\mftimer.inc"   ; MF Timer register
.include    "\st9\include\ad_c.inc"      ; A/D converter register
.include    "\st9\include\sci.inc"       ; SCI register
.include    "\st9\include\bitmacro.inc"  ; BIT macros
.list
.include        "nova.mac"

;**************************************************************************
;******************** Simbols and numerical equivalences ******************
;**************************************************************************

;***************************************
;********************* STACK Declaration
;***************************************
;SSTACK      := (15 * 16)               ; System stack address group C B
;USTACK      := (12 * 16)               ; User stack address group A
;//////////////////////// per usare emulatore///////////////////
SSTACK      := (13 * 16)                ; System stack address group C B
USTACK      := (11 * 16)                ; User stack address group A
;//////////////////////// per usare emulatore///////////////////


;***************************************
;********* text section absolute address
;***************************************
IVR_TABLE       = 0                     ; Start of interrupt vector table
SCI_IVR         = 040h                  ; Start SCI int vector
EXT_IVR         = 050h                  ; External interrupt base vector
MFT_IVR         = 0C0h                  ; Multifunction timer int vector
START           = 100h                  ; Start of C startup code
SDATA           = 3000h                 ; Static data start

REMOTE_TEST     = 0101010001010000b     ; Test pattern for remote

on              = 1             
off             = 0            

;***************************************
;********************* I/O ports equates
;***************************************
;** P0X EQUATES ( P4X EMULATED )
RWN             = 00010000b
RS0             = 00100000b
CSN             = 01000000b
O2              = 10000000b

;** P1X EQUATES ( P7X EMULATED / SHIFTED LEFT 2 )
ENABLE          = 00000100b ;(00000001b)
PLAYLN          = 00001000b ;(00000010b)
RECN            = 00010000b ;(00000100b)
RECLEDN         = 00100000b ;(00001000b)
PD118           = 01000000b ;(00010000b)
PD119           = 10000000b ;(00100000b)

;** P2X EQUATES ( P2X EMULATED )
BACKLIGHT       = 00000001b
SDI             = 00000010b
SCK             = 00000100b
SDO             = 00001000b
DTMFCP          = 00010000b
LED1            = 00100000b
LED2            = 01000000b
REMOTE          = 10000000b

;** P3X EQUATES ( P3X EMULATED )
HOOK            = 00000001b
ALARM1          = 00000010b
ALARM2          = 00000100b
ALARM3          = 00001000b
PROG            = 00010000b
RESET           = 00100000b

;** P5X EQUATES ( P5X EMULATED )
MUTE            = 00000001b
REL1            = 00000010b
REL2            = 00000100b
RING            = 00001000b
VOICE_CUE       = 00010000b
VOICE_ADDR      = 00100000b

;** MT8880 EQUATES
DTMFAVLB        = 00000100b
DTMFINOUT       = 00000101b
DTMFTONE        = 00000110b
TONEHIZ         = 0
TONEDIAL        = 1
TONEPBX         = 2
TONEBUSY        = 3


;**************************************************************************
;**************** Internal register variable allocations ******************
;**************************************************************************

;**************
;* Bank C end D             
;**************
; Used for SSP


;**************
;******* Bank B             
;**************
; Used for USP


;**************
;******* Bank A             
;**************
;       := RR174 \
;       := RR172  | 
;       := RR170  |
;       := RR168  | Non usare con emulatore
;       := RR166  |
;       := RR164  |
;       := RR162  |
;       := RR160 /


;**************
;******* Bank 9     
;**************
;       := RR158 \
;       := RR156  |
;       := RR154  |
;       := RR152  | Non usare con emulatore                    
;       := RR150  | 
;       := RR148  |
;       := RR146  |
;       := RR144 /


;**************
;******* Bank 8             
;**************
DISP_C  := R142                         ; 
DISP_F  := R141                         ; 
;        := R140                         ;
DIGIT_R := R139                         ;
SWITCH  := R138                         ;  
ALARM   := R137                         ; 
RING_C  := R136                         ;
TONE_1  := R135                         ; 
TONE_0  := R134                         ;
DIGIT   := R133                         ;
PHONE   := R132                         ; 
REM_OK  := R131                         ;
INT_TR  := R130                         ;
REM_C   := R129                         ; 
REM_F   := R128                         ; 
					

;**************
;******* Bank 7             
;**************
;       := RR126
;       := RR124
;       := RR122
;       := RR120
;       := RR118
;       := RR116 
;       := RR114 
;       := RR112 
					

;**************
;******* Bank 6             
;**************
;       := RR110
;       := RR108
;       := RR106
;       := RR104
;       := RR102
;       := RR100
;       := RR98  
;       := RR96  



;**************
;******* Bank 5                         ; I2C slave data
;**************
I2C_BUFF == 94
;       :=RR94
;       :=RR92
;       :=RR90
;       :=RR88
;       :=RR86
;       :=RR84
;       :=RR82
;       :=RR80



;**************
;******* Bank 4                         ; I2C bus manager
;**************
TOT_LENGHT := RR78
SLAVE_W    :=  R77                      ; Write slave control byte
SLAVE_R    :=  R76                      ; Read slave control byte

COUNTER    := RR70                      ; Bytes already transferred.
counter    :=  rr6
LENGHT     := RR70                      ; Number of bytes to be transfert.
lenght     :=  rr6

I2C_SLAVE  :=  R69                      ; Slave control byte.
SPI_STAT   :=  R68                      ; SPI transfer status.
SLAVE_STAT :=  R67                      ; Slave status.
SLAVE_OP   :=  R66                      ; Operation to do by the slave.
SLAVE_ADDR :=  R65                      ; Address in the slave memory.
BUFFER     :=  R64                      ; Temporary data to been transferred.
buffer     :=  r0


;**************
;******* Bank 3                         ; Timer0 context registers
;**************
;       :=RR62                          ; Don't define!
;       :=RR60
;       :=RR58
;       :=RR56
;       :=RR54
;       :=RR52
;       :=RR50
;       :=RR48



;**************
;******* Bank 2                         ; WatchDog context registers
;**************
;       :=RR46                          ; Don't define!
;       :=RR44
;       :=RR42
;       :=RR40
;       :=RR38
;       :=RR36
;       :=RR34
;       :=RR32



;**************
;******* Bank 1                         ; Page #1 free run space
;**************
;       :=RR30                          
;       :=RR28                          
;       :=RR26                          
;       :=RR24
;       :=RR22
;       :=RR20
;       :=RR18
;       :=RR16


;***********************
; Constant declarations.
;***********************

E2_SLAVE     == 10100000b           ; EEPROM I2C slave control byte
RTC_SLAVE    == 11010000b           ; Real Time Clock I2C slave control byte

READ         == 1                   ; Read mode
WRITE        == 2                   ; Write mode
VERIFY       == 3                   ; Alternate read mode

TRANS_CTRL   == 1                   ; The slave control transferred
TRANS_ADDR   == 2                   ; The slave address transferred
TRANS_DWR    == 3                   ; The data has been transmitted
TRANS_DRD    == 4                   ; The data has been received

EEP_OK       == 0                   ; Slave is OK.
LECT_ON      == 1                   ; Slave is reading a byte.
VERIF_ON     == 2                   ; Slave is reading the current byte.
ECR_ON       == 3                   ; Slave is programming a byte.
NO_ACK       == 4                   ; Slave has not acknowledged.

SLAVE_READY  == 80h                 ; Slave is ready for a new operation...



;**************************************************************************
;************************ TS INITIALIZATIONS CODE  ************************
;**************************************************************************
   .text                                   ; Start program segment


;***************************************
;**************** Interrupt vector table
;***************************************


   .org    IVR_TABLE
	.word   st9$entry                       ; Reset interrupt vector:Entry point
	.word   _trap_div0                      ; Divide by 0 interrupt service routine
	.word   _top_level_int                  ; Top Level interrupt service routine
	;***********************        
   .org    SCI_IVR
   .word   _SCI_it_s_rec_err               ; SCI receiver err int service
	.word   _SCI_9th_bit                    ; SCI 9th bit int service
   .word   _SCI_it_receive                 ; SCI RX int service
   .word   _SCI_it_transmit                ; SCI TX int service
	;***********************        
   .org    EXT_IVR                             
   .word   _A0_int                         ; Interrupt A0 ( Watchdog )
   .word   _A1_int                         ; Interrupt A1 ( 8880 IRQ )
   .word   _B0_int                         ; Interrupt B0 ( SPI int  )
   .word   _B1_int                         ; Interrupt B1 ( Remote   )
   .word   _C0_int                         ; Interrupt C0 ( External )
   .word   _C1_int                         ; Interrupt C1 ( External )
   .word   _D0_int                         ; Interrupt D0 ( External )
   .word   _D1_int                         ; Interrupt D1 ( External )
	;***********************        
   .org    MFT_IVR
   .word   _T0_int_0                       ; Multifunction timer interrupt
   .word   _T0_int_1                       ; Multifunction timer interrupt
   .word   _T0_int_2                       ; Multifunction timer interrupt
   .word   _T0_int_3                       ; Multifunction timer interrupt
	;***********************        



;***************************************
;************ Linker options entry point
;***************************************
   .org    START                                ; Start code
	;***********************        
st9$entryRS::                                   ; Entry point for Separate 
   sdm                                          ; Read Only Environment -iI
	;***********************        
st9$entryR_::                                   ; Entry point for 
   or      FLAGR,#10b                           ; Read Only Environment -I 
   jr      st9$entry_GO                         ; Set user flag:
                                                ; data (ROM) to bss (RAM) copy
	;***********************        
st9$entry_S::                                   ; Entry point for Separate
   sdm                                          ; Address Space -i
	;***********************        
st9$entry__::                                   ; Entry point for 
   and     FLAGR,#~10b                          ; Common Address Space
st9$entry_GO::                                  ;


;***************************************
;********* system register configuration 
;***************************************
	srp     #(14*2)                         ; Set register bank E

	spp     #0                              ; Init page pointer register
   ld      moder,#(sspm | uspm | div2m)    ; Set USP,SSP in int reg - Ck/2
   ld      usplr,#(USTACK)                 ; Init User stack pointer
   ld      ssplr,#(SSTACK)                 ; Init System stack pointer
   ld      cicr,#(gcenm | iamm | cplm)     ; CPL=7,DI,enable counter,nested 
   and     flagr,#03h                      ; Clr flag register

   srp     #(15*2)                         ; Set bank register F

;***************************************
;**************** I/O port configuration
;***************************************
   spp     #P2C_PG                         ; Port 2 page
;   ld      p2c2r,#10011111b                ;\
;   ld      p2c1r,#01111100b                ; | Set port 2
;   ld      p2c0r,#11011110b                ;/

    ld      p2c2r,#11011110b                ;\
    ld      p2c1r,#01111100b                ; | Set port 2
    ld      p2c0r,#11011111b                ;/
;   ld      p2dr, #00000000b
   ;emulator board  ^     ^
	;***********************
   spp     #P3C_PG                         ; Port 3 page
   ld      p3c2r,#11111111b                ;\ 
   ld      p3c1r,#00000000b                ; | Set port 3
	ld      p3c0r,#11111111b                ;/
   ;***********************
   spp     #P4C_PG                         ; Port 4 page
	ld      p4c2r,#00000000b                ;\ 
	ld      p4c1r,#11110000b                ; | Set port 4
	ld      p4c0r,#00000000b                ;/
   ld      p4dr ,#00000000b                ;
	;***********************
   spp     #P5C_PG                         ; Port 5 page
   ld      p5c2r,#00001000b                ;\
	ld      p5c1r,#11110111b                ; | Set port 5
   ld      p5c0r,#00000000b                ;/
   ld      p5dr ,#00000000b                ;
	;***********************
   spp     #P7C_PG                         ; Port 7 page
	ld      p7c2r,#00100001b                ;\
	ld      p7c1r,#11011110b                ; | Set port 7
	ld      p7c0r,#00100011b                ;/
   ld      p7dr ,#00111111b                ;
   ;***********************


;***************************************
;*************** interupts configuration
;***************************************
   spp     #EXINT_PG                       ; External interrupts page  
   ld      eimr,#00000001b                 ; Unmask interrupts
   ld      eitr,#10001101b                 ; Set int triggers
   ld      eivr,#01010100b                 ; Set int_vect=5X / NMI
   ld      eiplr,#01100100b                ; Interrups priority (A-D-BC)
;  clr     nicr                            ; NMI TLI disabled   
;////////////////////// per usare emulatore ////////////////
   ld      nicr,#tlnmm                     ; NMI TLI enabled
;///////////////////////////////////////////////////////////
	ld      wcr,#01000000b                  ; Disable WatchDog
   clr     eipr                            ; Clear ext pending int.

;***************************************
;****************************** init SCI
;***************************************
	spp     #SCI1_PG                        ; Set SCI page register
	ld      s_brghr,#00                     ; Set baud_rate=19.200
	ld      s_imr,#00h                      ; Set int mask register
   ld      s_ivr,#SCI_IVR                  ; SCI interrupt vector
   ld      s_idpr,#00h                     ; Set interrupt priority=2
   ld      s_chcr,#(wl8 | sb10)            ; 8 data, 1 stop, no parity
   ld      s_ccr,#0                        ; 16X, internal baud rate
   clr     s_isr                           ; Clr pending interrupt
   ldw     s_brgr,#39                      ; Set baud_rate=19.200 (24Mhz)


;***************************************
;******************************* init WD
;***************************************
	spp     #WDT_PG                         ; Set Watch_dog timer page
   ld      wdtpr,#29                       ; 10 usec prescaler
   ldw     wdtr ,#5000                     ; 50 msec counter
   ld      wdtcr,#(stsp | 48)              ; Continuous, timer, start now

;***************************************
;****************************** init SPI
;***************************************
   spp     #SPI_PG                         ; Set SPI page
   ld      spicr,#(bms | SP_128)           ; I2C bus, 100KHz clock

                     
;***************************************
;******************** Serial line enable
;***************************************
;* Send a dummy char at power up
;* to set a correct state of TXempty flag.
;**************
;
;   srp     #0                              ; Set register bank 0
;   ;***********************
;   spp     #SCI1_PG                        ; Set SCI page register
;   ld      S_TXBR,#0AAh                    ; Trasmit dummy char
;   ;***********************
;   delay   #2000                           ; Delay to end tx
;   ;***********************                
;   and     S_ISR,#00000011b                ; Clear pending bit
;   ld      S_CCR,#80h                      ; Disable loop back mode
;   ld      s_idpr,#00001000b

;**************************************************************************
;************************** TS MAIN PROGRAM *******************************
;**************************************************************************
init::

	srp     #0                              ; Set register bank 0
	spp     #0                              ; Set Page 0

	call    display_init
	call    _8880_init
   clr     EIPR
;   nop

   ei
;jx i2c_test



open::

   print   line1, message_open
   print   line2, message_name
   sleep   #1500

   call    display_bufclr

;   jx tony
;   jx zeppo

   and     P5DR ,#~00110001b
;   or      P5DR ,#00000001b

idle::
   spp     #0
   ldw     rr0,#frame_buffer            ; loads the frame buffer
   ldw     (rr0),#0                     ; zero the buffer
   ld      ALARM,#0
   ld      DIGIT_R,#0
   ld      HOOK,#0
   ld      SWITCH,#0
   ld      TONE_0,#255
   or      EIMR,#10000000b
   relay1  off
   relay2  off

   print   line1, message_ready
   print   line2, message_time

main::
   loop {
      ifbit SWITCH, #PROG
         jx       progr
      }
      if [ALARM > #0]
      {
         print    line2, message_altrig
         jx       allarme
      }
      if [PHONE != #0]
      {
         jx       hook
      }
      ldw    rr0,(frame_buffer)
      ifw [rr0 == #REMOTE_TEST]
      {
         print    line2, message_alrem
         jx       allarme
      }
      call    clock
   }

allarme::

   print   line1, message_alarm
;   sleep   #1000
   relay1  on

   sleep   #1000

;   ld      r0,#DTMFINOUT
;   call    _8880_ctrl_wr

   ld      r0,#1001b
   call    _8880_ctrl_wr
   ld      r0,#0000b
   call    _8880_ctrl_wr

;   ldw     (combtel_buffer),#0A00h
;   call    combtel_dtmf
;   sleep   #1000

   ldw     rr0,#combtel_buffer
   ldw     rr2,#numero
   ld      r4,#32
   loop [r4] {
      lddd (rr0)+,(rr2)+
	}
   call    combtel_dtmf
   sleep   #2000
   ifbit SWITCH, #RESET
     jx       annullamento
   }

;   ld      r0,#DTMFTONE
;   call    _8880_ctrl_wr
;   ld      r4,#20
;   loop [r4] {
;      call    _tone_sample
;      if [r0 == #TONEHIZ]
;      {
;         break
;      }
;      ifbit SWITCH, #RESET
;         jx       annullamento
;      }
;   }
;   if [r4 == #0]
;   {
;      inc   r6
;      jx    allarme
;   } else {

;      ld      r0,#DTMFTONE
;      call    _8880_ctrl_wr


   ld      r0,#1001b
   call    _8880_ctrl_wr
   ld      r0,#0000b
   call    _8880_ctrl_wr

;      ld      r4,#6
      ld      DIGIT_R,#255
      ld      DIGIT,#0
      while [DIGIT != #5] {
         call    reset_message
         sleep   #100
         call    play_begin
         sleep   #5000
         call    play_end
         ifbit SWITCH, #RESET
            jx       annullamento
         }
      }
      ld      DIGIT_R,#0
;  }
   ld      r0,#DTMFTONE
   call    _8880_ctrl_wr
   delay   #8000

;   and     P5DR ,#~00000001b

   loop {
      call    _tone_sample
      if [r0 == #TONEBUSY]
      {
         break
      }
      ifbit SWITCH, #RESET
         jx       annullamento
      }
   }
   relay1  off
   print   line1, message_alarm
   print   line2, message_ok
   sleep   #2000
   jx      idle
   
annullamento::
   print   line1, message_alarm
   print   line2, message_break
   sleep   #2000
   jx      idle


hook::
   print   line1, message_cornetta
   print   line2, message_alzata
;   sleep   #1000
   if [PHONE == #0]
   {
      print   line2, message_abbassata
;      sleep   #1000
      jx      idle
   }
   jx      hook


progr::    
   print   line1, message_progst
   print   line2, message_tastibegin
   relay1  on
   relay2  on

   ld      r0,#1001b
   call    _8880_ctrl_wr
   ld      r0,#0000b
   call    _8880_ctrl_wr

   ld      DIGIT_R,#255

;   ld      r0,#80
;   loop [r0]
;   {
;      sleep   #100
;      if [PHONE == #1]
;      {
;         break
;      }
;   }
;   if [PHONE == #0]
;   {
;      jx      idle
;   }
;   print   line1, message_tastiend1
;   print   line2, message_tastiend2
;   sleep   #1000
   ld      r2,#0
   ld      DIGIT,#0
	ld      r0,#DTMFINOUT
	call    _8880_ctrl_wr

   loop {
      ld      r1,DIGIT
      clr     DIGIT
      if [r1 == #11]
      {
         inc      r2
         if [r2 > #6]
         {
           xor    r2,r2
         }
      }
      if [r1 == #12]
      {
         call  prog_menu 
      }
      print   line2, message_tastipr
      switch [r2]
      {
         case #0:
            print   line1, menu_oradata
         case #1:
            print   line1, menu_messaggi
         case #3:
            print   line1, menu_numeri
         case #4:
            print   line1, menu_telecomando
         case #5:
            print   line1, menu_tempi
         case #6:
            print   line1, menu_riservato
      }
;      if [PHONE == #0]
;      {
;         break
;      }
;      ifbit SWITCH, #RESET
;         break
;      }
      ifnobit SWITCH, #PROG
         break
      }
      clr     r1
   }
   print   line1, message_fineprog1
   print   line2, message_fineprog2
   sleep   #1000
   jx      idle


prog_menu::
   loop {
      ld      r1,DIGIT
      clr     DIGIT
      switch [r2]
      {
         case #0:
            print   line1, sub_oradata1
            print   line2, sub_oradata2
         case #1:
            print   line1, sub_messaggi1
            print   line2, sub_messaggi2
         case #3:
            print   line1, sub_numeri1
            print   line2, sub_numeri2
         case #4:
            print   line1, sub_telecomando1
            print   line2, sub_telecomando2
         case #5:
            print   line1, sub_tempi1
            print   line2, sub_tempi2
         case #6:
            print   line1, sub_riservato1
            print   line2, sub_riservato2
      }
      if [r1 == #11]
      {
         break
      }
      if [r1 == #12]
      {
         switch [r2]
         {
            case #1:
               call   prog_messaggi
            case #3:
               call   prog_numeri
         }
      }
      clr     r1
;      if [PHONE == #0]
;      {
;         break
;      }
;      ifbit SWITCH, #RESET
;         break
;      }
      ifnobit SWITCH, #PROG
         break
      }
   }
   ret

prog_messaggi::
;   loop {
;      ld      r1,DIGIT
;      clr     DIGIT
;      ifbit P3DR,#PROG
;         while [] {
;
;         }
;       if [DIGIT == #10]
;       {
         print   line1, messaggi_begin1
         print   line2, messaggi_begin2

         call  reset_message
         sleep #100
         call  rec_begin
         sleep #5000
         call  rec_end

         print   line1, messaggi_end1
         print   line2, messaggi_end2
         sleep   #1000

;         break
;      }
;      clr     r1
;      if [r1 == #11]
;      {
;         break
;      }
;      if [PHONE == #0]
;      {
;         break
;      }
;   }
   ret

prog_numeri::
   call    display_bufclr
   print   line1, numeri_begin1
   ld      r8,#0
   ldw     rr6,#line2
   ldw     rr10,#numero
   ld      (rr10),#0

   loop {
      ld      r1,DIGIT
      clr     DIGIT

      if [r1 != #0]
      {
         bcd2ascii  r1,r9
         if [r8 <= #15]
         {
           ld      (rr6)+,r9
           ld      (rr10)+,r1
           inc     r8
         }
      }
      if [r1 == #12]
      {
         ld     (rr10),#0
         break
      }
      clr     r1
   }
   if [(numero) != #0]
   {

     ldw     rr6,#i2c_buffer
     ldw     rr10,#numero
     loop [r8] {
        lddd (rr6)+,(rr10)+
     }

;     i2c WRITE, E2_SLAVE, #0, r8
   }
   ret





;*************************************************************************
;*************************************************************************
;*************************************************************************
;*************************************************************************

zeppo::
	;call     att_viva_voce

;jx xyz
   set_bit P5DR,REL1       ;on hook
   set_bit P5DR,REL2       
   delay   #60000
	delay   #60000
	
eee::        
	
;  or      EIMR,#(ALARM1 | ALARM2 | ALARM3 | ALARM4)
;  clr     eipr
;  nop
	
;   jx      rem

xyz:: 
;       attendo ring per prendere linea
;   loop {
;      ifnobit P5DR,#RING    ;ring se bit == 0
;         set_bit P5DR,REL1       ;on hook
;         break
;      }
;   }

xxx1::
;////////////////////////////////////////////////////////////////////////



;   or      P5DR,#8
;   ldw     rr0,#0fffh
;   loopw [rr0] {
;      delay   #60
;   }


;  ld      r0,#DTMFTONE
;   ld      r0,#DTMFINOUT
;   call    _8880_ctrl_wr


cazzillo::
;        loop {
;           ifbit   P2DR,#TONE
;              clr_bit   P5DR,REL1
;           }
;        do {
;                nop
;                call    _8880_ctrl_rd
;                nop
;                ld      r1,r0
;                and     r0,#00000010b
;        } while [r0 == #0] 
;
;        }
;        ld      r0,#DTMFINOUT
;        call    _8880_ctrl_wr
;        delay   #8000


zzz:: 

	;******
	ld      r0,#1111b
	call    _8880_ctrl_wr
	ld      r0,#0000b
	call    _8880_ctrl_wr
	;******
	ld      r0,#10     ;**** cifra 1
	call    _8880_data_wr        
	;******
	do {
		nop
		call    _8880_ctrl_rd
		nop
		ld      r1,r0
		and     r0,#00000010b
	} while [r0==#0] 

	delay   #60000
	delay   #60000
	delay   #60000
	delay   #60000
	delay   #60000
	delay   #60000
	delay   #60000
	delay   #60000
	delay   #60000

	;******
	ld      r0,#1111b
	call    _8880_ctrl_wr
	ld      r0,#0000b
	call    _8880_ctrl_wr
	;******
	ld      r0,#10     ;**** cifra 1
	call    _8880_data_wr        
	;******
	do {
		nop
		call    _8880_ctrl_rd
		nop
		ld      r1,r0
		and     r0,#00000010b
	} while [r0==#0] 
;  and    r1,#00000100b
;  if [r1!=#0] {
;     call    _8880_data_rd
;  }
	jx      pino

fezza::       
loop {
	delay  #30000
	ld      r0,#1111b
	call    _8880_ctrl_wr
	ld      r0,#0000b
	call    _8880_ctrl_wr

   ld      r0,#1    ;**** cifra 2
	call    _8880_data_wr        
	;******
	do {
		nop
		call    _8880_ctrl_rd
		nop
		ld      r1,r0
		and     r0,#00000010b
	} while [r0 == #0] 
;  and    r1,#00000100b
;  if [r1!=#0] {
;     call    _8880_data_rd
;  }
}

pino::

;  ld      r0,#DTMFTONE
	ld      r0,#DTMFINOUT
	call    _8880_ctrl_wr


	call    display_bufclr

	ldw     rr6,#display_buffer
	ldw     rr2,#malvenuto
	ld      r4,#16
	loop [r4] {
      lddp (rr6)+,(rr2)+
	}
	xor     r8,r8


peppo::        

   and     P5DR ,#~00000001b
   and     P5DR ,#~00110000b

	
	loop {
	   delay   #8000
	   call    _8880_ctrl_rd
	   ifbit   r0,#DTMFAVLB            ;ricevuta cifra DTMF ?
	      delay   #8000
	      call    _8880_data_rd
	      delay   #8000
	      ld   r2,r0
	      inc  r8
	      if [r8 > #16] {
            xor     r8,r8
            inc     r8
            ldw     rr6,#display_buffer
            addw    rr6,#16
	      }
	      switch [r0] {
	      case #0:
            break
	      case #10:
            ld      r4,#48
            ld      (rr6)+,r4
            call    reset_message
	      case #11:
            ld      r4,#00101010b
            ld      (rr6)+,r4
            call    rec_begin
            sleep   #5000
            call    rec_end
	      case #12:
            ld      r4,#00100011b
            ld      (rr6)+,r4
            call    play_begin
            sleep   #5000
            call    play_end
	      default:
            ld      r4,#48
            add     r4,r2
            ld      (rr6)+,r4
	      }
	   }
	}

	call    _8880_scancp
	switch [r0] {
	   default:
	}
	
stop::
	jx      stop



rem::
   spp     #0
;   call    T0_remote

   and     P5DR,#~1
   or      EIMR,#10000000b

	ldw     rr0,#display_buffer
	ldw     rr2,#telecomando
	ld      r4,#16
	loop [r4] {
	   lddd (rr0)+,(rr2)+
	}             
	loop {
      ldw     rr6,#display_buffer+16
      ldw     rr8,(frame_buffer)
      ld      r1,#16
      loop [r1] 
      {
         ld      r2,#48
         ifbitw  rr8,#1000000000000000b
            ld      r2,#49
         }
         rlcw    rr8
         ld      (rr6)+,r2
      }
	}


tony::
   call    display_bufclr

   spp     #0

   ld      r0,#DTMFTONE
   call    _8880_ctrl_wr

   relay1  off
   print   line1, msgtony
   print   line2, message_attendere
   loop {
      call    _tone_sample
      if [r0 == #TONEHIZ] {
         print   line2,msghiz
      }
      if [r0 == #TONEDIAL] {
         print   line2,msglibero
      }
      if [r0 == #TONEBUSY] {
         print   line2,msgoccupato
         relay2  off
         relay1  off
      }
      if [r0 == #TONEPBX] {
         print   line2,msgpbx
         sleep   #1000
         ld      (combtel_buffer),#10
         ld      (combtel_buffer+1),#0
         call    combtel_dtmf
      }
   }


i2c_test::

     ld SLAVE_STAT,#SLAVE_READY
     pushu EIMR

;     ldw     rr6,#i2c_buffer
;     ldw     rr10,#num2
;     ld      r8,#4
;     loop [r8] {
;        lddp (rr6)+,(rr10)+
;     }

     and   EIMR,#00000000b

     i2c READ, RTC_SLAVE, #0, #4

     clr   EIPR
     popu  EIMR
     sleep #100


   jx  i2c_test



user_main::

	nop
	nop
	jx      user_main


;**************************************************************************
;********************** INTERRUPT SERVICE ROUTINES ************************
;**************************************************************************


;***************************************
;************************ T0 interrupt 0
;***************************************
_T0_int_0::
	pushu	PPR
   ;***********************                
   spp     #T0D_PG                         ; Enable Timer0 page
   and     T_FLAGR,#~(ouf | cp0 | cp1)     ; Clear Overflow/Underflow/Capture
	spp     #0
   ;***********************
   or    SLAVE_STAT,#SLAVE_READY           ; Write sequence is finished.
   popu  PPR
	iret                                    


;***************************************
;************************ T0 interrupt 1
;***************************************
_T0_int_1::
	pushw   RPP                             ; Save RPP
	push    PPR                             ; Save PPR
   srp     #(3*2)                          ; Switch context
   ;***********************                
   spp     #T0D_PG                         ; Enable Timer0 page
   and     T_FLAGR,#~(ouf | cp0 | cp1)     ; Clear Overflow/Underflow/Capture
	spp     #0
   ;***********************
   inc     REM_F
   ifbit   P2DR,#REMOTE
      inc      REM_C
   }
   if [REM_C > #11]
   {
      clr      REM_F                       ; Clear remote flags
      clr      REM_C                       ; Clear remote flags
      clr      EIPR
      nop
      or       EIMR,#10000001b             ; Re-enable WD and REMOTE
      spp      #T0D_PG                     ; Enable Timer0 page
      and      T_TCR,#~cen                 ; Stop Timer0
      inc      REM_OK                      ; Increment validity flag
   }
   if [REM_F > #11]
   {
      clr      REM_F                       ; Clear remote flags
      clr      REM_C                       ; Clear remote flags
      clr      EIPR
      nop
      or       EIMR,#10000001b             ; Re-enable WD and REMOTE
      spp      #T0D_PG                     ; Enable Timer0 page
      and      T_TCR,#~cen                 ; Stop Timer0
   }
	;***********************                
	pop     PPR                             
	popw    RPP                             ; Restore context    
	iret                                    


;***************************************
;************************ T0 interrupt 2
;***************************************
_T0_int_2::
   iret

;***************************************
;************************ T0 interrupt 3
;***************************************
_T0_int_3::
   iret





;***************************************
;**************************** _trap_div0
;***************************************
_trap_div0::                                    ; Divide by 0 interrupt service routine
	ret




;***************************************
;******************* Top level interrupt
;***************************************
_top_level_int::                                ; Top Level interrupt service routine
	iret



;***************************************
;****************** SCI errors interrupt
;***************************************
_SCI_it_s_rec_err::
	iret




;***************************************
;***************** SCI 9th bit interrupt
;***************************************
_SCI_9th_bit::
	iret
	



;***************************************
;**************** SCI TX empty interrupt
;***************************************
_SCI_it_transmit::
	iret




;***************************************
;********************* SCI RX interrupt
;***************************************
_SCI_it_receive::
	iret



;***************************************
;********************* WD timer int 50ms
;***************************************
_A0_int::
   pushu   PPR                             ; Save PPR
   pushuw  RPP                             ; Save RPP
   srp     #(2*2)                          ; Switch context
   spp     #0
   clr     EIPR                            ; clear pending interrupts
   nop
   pushu   EIMR
   clr     EIMR                            ; disable all interrupts
   ;***********************
   call    display_update                  ; resfresh display
	;***********************
   ifbit   P3DR,#ALARM1                    ; poll external alarms
      ld      ALARM,#ALARM1
   }
   ifbit   P3DR,#ALARM2
      ld      ALARM,#ALARM2
   }
   ifbit   P3DR,#ALARM3
      ld      ALARM,#ALARM3
   }
   ifbit   P3DR,#HOOK                      ; poll phone hook status
      ld      PHONE,#1
   } else {
      ld      PHONE,#0
   }
   ifbit   P3DR,#RESET                     ; poll user switches
      or      SWITCH,#RESET
   } else {
      and     SWITCH,#~RESET
   }
   ifbit   P3DR,#PROG
      or      SWITCH,#PROG
   } else {
      and     SWITCH,#~PROG
   }
   ifbit   P5DR,#RING                      ; poll ring detector
      ld      RING_C,#1
   }
   ;***********************
   if [TONE_0 < #36]                       ; poll line-tone input to
   {                                       ; calculate a silence/tone ratio
      ld      r0,#200                    
      loop [r0] {
         ld      r1,P2DR
         and     r1,#DTMFCP
         if [r1 == #DTMFCP]
         {
            inc     TONE_1
            break
         }
         nop
         nop
      }
      inc     TONE_0
   }
   ;***********************
   if [DIGIT_R == #255]
   {
      call    _8880_ctrl_rd                ; see if valid dtmf has been
      ifbit   r0,#0100b                    ; received from the MT8880
;         delay   #8000
         call    _8880_data_rd
         ld      DIGIT,r0
      }
   }
   ;***********************
   spp     #0
   clr     EIPR                            ; WD generate spurious
   nop
   popu    EIMR                            ; re-enable all interrupts
   popuw   RPP                             ; Restore context
   popu    PPR
	iret

;***************************************
;**************************** MT8880 IRQ
;***************************************
_A1_int::
   iret
   pushu   PPR
   pushuw  RPP
   srp     #(3*2)
   spp     #0
   clr     EIPR
   nop

   delay   #8000
   call    _8880_ctrl_rd
   ifbit   r0,#0101b
      delay   #8000
      call    _8880_data_rd
      ld      DIGIT,r0
	}
   delay   #8000
   ld      r0,#DTMFINOUT
	call    _8880_ctrl_wr

   popuw   RPP
   popu    PPR
	iret


;***************************************
;************************* SPI Interrupt
;***************************************
_B0_int::
   pushu   PPR
   pushuw  RPP
   srp     #(4*2)
   spp     #0
   if [SPI_STAT == #TRANS_DRD]           
   {
      ld    buffer,SPIDR         

      ld    i2c_buffer(lenght),buffer
      decw  lenght
      if    [SETZ]

;      ld    i2c_buffer(counter),buffer
;      incw  counter
;      if    [counter > lenght]


      {
         call  GEN_STOP   
         ld    SLAVE_STAT,#SLAVE_READY 
		} else {
         call  GEN_ACK 
         ld    SPI_STAT,#TRANS_DRD
         spp   #0
         ld    buffer,#0FFH 
      } 
	} else {
      call  TEST_ACK          
      if [SLAVE_STAT == #NO_ACK]
      { 
         call  GEN_STOP      
         or    SLAVE_STAT,#SLAVE_READY   
		} else {
         switch [SPI_STAT] {
         case  #TRANS_CTRL:
            if [SLAVE_STAT == #VERIF_ON]
            {
               ld    SPI_STAT,#TRANS_DRD
               spp   #0
               ld    buffer,#0FFH 
				} else {
               ld    SPI_STAT,#TRANS_ADDR
					spp	#0
               ld    buffer,SLAVE_ADDR
            }
         case  #TRANS_ADDR:
            if [SLAVE_OP == #READ]
            {
               call  GEN_START   
               ld    SPI_STAT,#TRANS_CTRL
               ld    buffer,SLAVE_R
               ld    SLAVE_STAT,#VERIF_ON  
				} else {
					spp	#0
               ld    SPI_STAT,#TRANS_DWR
               ld    buffer,i2c_buffer(lenght)
            } 
         case  #TRANS_DWR:
				spp	#0
            decw  lenght  
            if    [CLZ]
            {
               ld    buffer,i2c_buffer(lenght)
            } else {  
               call  T0_I2C
               call  GEN_STOP 
            } 
         }
      }
   } 
   ld    SPIDR,buffer
	popuw	RPP
	popu	PPR
	iret

;***************************************
;******** external or Software interrupt
;***************************************
_B1_int::
   iret

_C0_int::
   iret

_C1_int::
   iret

_D0_int::
   iret


_D1_int::
	push    PPR                             ; Save PPR
	pushw   RPP                             ; Save RPP
   srp     #(3*2)                          ; Switch context
   spp     #0
   clr     EIPR
   nop
   delay   #30
   ifbit P2DR,#REMOTE                      ; Is here a level 1
      delay   #100
      ifbit P2DR,#REMOTE                   ; after 200 usec
        and     EIMR,#~10000001b           ; Disable other interrupts
;        delay   #470
;        spp     #T0D_PG                    ; 
;        or      T_FLAGR,#(cp0 | ouf)       ; Trigger CP0 and OUF
;        or      T_TCR,#cen                 ; Start the timer
        spp     #0
        call    _frame_sample
        or      EIMR,#10000001b            ; Re-enable other interrupts
      }
   }
	popw    RPP                             ; Restore context    
	pop     PPR
	iret                                    


;**************************************************************************
;******************************** DISPLAY *********************************       
;**************************************************************************

				    
;***************************************
;************************** init display
;***************************************
display_init::
	ld      P4DR,#01001111b                 ; scrittura istruzioni
	;***********************    
	ld      r0,#00110000b                   ;\
	call    _display_nibble_wr              ; |
	delay   #4000                           ; | 
	ld      r0,#00110000b                   ; |
	call    _display_nibble_wr              ; | display software reset
	delay   #100                            ; | 
	ld      r0,#00110000b                   ; |
	call    _display_nibble_wr              ; |
	delay   #100                            ;/
	;***********************
	call    _display_ready
	ld      r0,#00100000b                   
	call    _display_nibble_wr              ; set interface to 4 bit
	;***********************
	call    _display_ready
	ld      r0,#00101000b                   ; set 2 lines, 5*7 font
	call    _display_write
	;***********************
	call    _display_ready
	ld      r0,#00001000b                   ; display off
	call    _display_write
	;***********************
	call    _display_ready
	ld      r0,#00001110b                   ; display on
	call    _display_write
	;***********************
	call    _display_ready
	ld      r0,#00000110b                   ; entry mode set
	call    _display_write

	ret




;***************************************
;************************ display update
;***************************************

display_return::
	call    _display_ready
   ld      P4DR,#01001111b                   ; set_dis_inst_wr_mode
   ld      r0,#00000010b                     ; return home
	call    _display_write
	ret

display_bufclr::
	ldw     rr8,#display_buffer
   ld      r10,#32                           ; loop write 32 char
	ld      r11,#00100000b
   loop [r10] {                              ; fill display buffer
      ld      (rr8)+,r11                     ; with spaces
	}
	ret

display_update:
	pushuw  rr0
	pushuw  rr2
	pushuw  rr8
	pushuw  rr10
	;***********************
	call    _display_ready
   ld      P4DR,#01001111b                   ; scrittura istruzioni
   ld      r0,#10000000b                     ; first line (set address)
	call    _display_write
	;***********************
	ldw     rr8,#display_buffer
	ld      r10,#16
   loop [r10] {                              ; loop 16 times (a line)
		call    _display_ready
      ld      P4DR,#01101111b                ; scrittura dati
		ld      r0,(rr8)+
		call    _display_write
	}
	;***********************
	call    _display_ready
   ld      P4DR,#01001111b                   ; scrittura istruzioni
   ld      r0,#11000000b                     ; second line (set address)
	call    _display_write
	;***********************
	ld      r10,#16
   loop [r10] {                              ; loop 16 times (a line)
		call    _display_ready
      ld      P4DR,#01101111b                ; scrittura dati
		ld      r0,(rr8)+
		call    _display_write
	}
	popuw   rr10
	popuw   rr8
	popuw   rr2
	popuw   rr0
	;*********************** 
	ret



;***************************************
;****************** display nibble write
;***************************************
_display_nibble_wr::
	pushu   PPR
	spp     #P7D_PG
	;***********************
   or      P7DR,#ENABLE            ; set E
	;*********************** 
	swap    r0
	and     r0,#00001111b
	ld      r2,P4DR
	and     r2,#11110000b             
	or      r0,r2
	ld      P4DR,r0                 ; write
	;***********************
   and     P7DR,#~ENABLE           ; reset E
	;***********************
	popu    PPR                 
	ret

;***************************************
;******************* display nibble read
;***************************************
_display_nibble_rd::
	pushu   PPR
	spp     #P7D_PG                 
	;***********************
   or      P7DR,#ENABLE            ; set E
	nop
   and     P7DR,#~ENABLE           ; reset E
	;***********************
	nop
	ld      r0,P4DR                 ; read
	and     r0,#00001111b
	swap    r0
	;*********************** 
	popu    PPR                 
	ret


;***************************************
;******************** display char write
;***************************************
_display_write::
	pushu   r0
	call    _display_nibble_wr
	popu    r0
	swap    r0
	call    _display_nibble_wr
	ret

;***************************************
;******************** display char write
;***************************************
_display_read::
	call    _display_nibble_rd
	ld      r1,r0
	call    _display_nibble_rd
	swap    r0
	or      r1,r0
	ld      r0,r1
	ret

;***************************************
;******************** is display ready ?
;***************************************
_display_ready:: 
	pushu   P4DR
	spp     #P7D_PG                 
	;***********************
	ld      P4DR,#01011111b         ; modo instruzioni & read
	;***********************
   ld     r2,#0FFh
   loop [r2] {
	   call    _display_read
      ifnobit r0,10000000b         ; controlla il BF
	      break
	   }
	}
	popu    P4DR
	ret


;**************************************************************************
;******************************** EEPROM **********************************       
;**************************************************************************



;***************************************
;*************** Write data to EEPROM #1
;***************************************
wr_data_to_E1::
;  set_CSE1
	ld      r0,#1b
	rdwr_data_to_SPI
	ld      r0,#01000000b
	rdwr_data_to_SPI
	ld      r0,#55h
	rdwr_data_to_SPI
;  rst_CSE1
	ret



;***************************************
;*************** Read data to EEPROM #1
;***************************************
rd_data_from_E1::
;  set_CSE1
	ld      r0,#1b
	rdwr_data_to_SPI
	ld      r0,#10000000b
	rdwr_data_to_SPI
	ld      r0,#00h
	rdwr_data_to_SPI
;  rst_CSE1
	ret



;**************************************************************************
;******************************** DRIVER **********************************       
;**************************************************************************

;****************************************
;*************** LEDs *******************
;****************************************

FlashLed::
;  spp     #0
;  srp     #0
	loop [r1] {
	   call    LedOn
      sleep   #200
	   call    LedOff
      sleep   #200
	   cpl     r0
	}
	ret

LedOff::
	cpl     r0
	and     P2DR,r0
;  clr_bit  P2DR,r0
	ret


LedOn::
	or      P2DR,r0
;  set_bit  P2DR,r0
	ret


;**************************************************************************
;******************  Composizione numeri telefonici  **********************
;**************************************************************************
				    
;****************************************
;******** Combinatore telefonico decadico
;****************************************
combtel_decadic::
	ldw  rr8,#combtel_buffer
	loop [r10] {                    ; r10 numeri da comporre
	   ld      r11,(rr8)+           ; rr8 contiene i numeri
	   loop [r11] {
	      clr_bit P5DR,REL1       
	      delay   #20000            ; da calibrare
	      set_bit P5DR,REL1
	      delay   #20000            ; da calibrare
	   }
      sleep   #500
	}
	ret        


;****************************************
;************ Combinatore telefonico DTMF
;****************************************
combtel_dtmf::
   ldw     rr8,#combtel_buffer
   do {
      ld      r0,#1111b
      call    _8880_ctrl_wr
      ld      r0,#0000b
      call    _8880_ctrl_wr
      ld      r0,(rr8)+
		call    _8880_data_wr
      do {
         nop
         call    _8880_ctrl_rd
         nop
         ld      r1,r0
         and     r0,#00000010b
      } while [r0 == #0]
      sleep   #500
   } while [(rr8) != #0]
	ret


;**************************************************************************
;**********  MT 8880 (Tranceiver DTMF / Call progress tone)  **************
;**************************************************************************

;***************************************
;********* init comb-tel
;***************************************
_8880_init::
	call    _8880_ctrl_rd
	ld      r0,#0000b
	call    _8880_ctrl_wr
	ld      r0,#0000b
	call    _8880_ctrl_wr
	ld      r0,#1000b
	call    _8880_ctrl_wr
	ld      r0,#0000b
	call    _8880_ctrl_wr
	ret

;***************************************
;********* write to MT8880 data register
;***************************************
;* input: r0 bit3..0
;*        bit 7,,4 must be 0
;***************************************
_8880_data_wr::
	pushu   P4DR
	ld      r1,#00000000b           ; assert data write end CS
	ld      P4DR,r1
	or      r1,#10000000b
	ld      P4DR,r1
	or      r0,r1
	ld      P4DR,r0
	nop
	nop
	and     r0,#01111111b
	ld      P4DR,r0
	nop
	popu    P4DR
	ret



;***************************************
;****** write to MT8880 control register
;***************************************
;* input: r0 bit3..0
;*        bit 7,,4 must be 0
;***************************************
_8880_ctrl_wr::
	pushu   P4DR
	ld      r1,#00100000b           ; assert data write end CS
	ld      P4DR,r1
	or      r1,#10000000b
	ld      P4DR,r1
	or      r0,r1
	ld      P4DR,r0
	and     r0,#01111111b
	ld      P4DR,r0
	delay   #20
	popu    P4DR
	ret




;***************************************
;************* read MT8880 data register
;***************************************
;* output: r0 bit3..0
;*
;***************************************
_8880_data_rd::
	pushu   P4DR
	ld      r1,#00011111b           ; assert data read CS
	ld      P4DR,r1
	or      r1,#10000000b
	ld      P4DR,r1
	ld      r3,P4DR
	ld      r0,#01111111b
	ld      P4DR,r0
	ld      r0,r3
	and     r0,#00001111b        
	delay   #20
	popu    P4DR
	ret




;***************************************
;********** read MT8880 control register
;***************************************
;* output: r0 bit3..0
;*
;***************************************
_8880_ctrl_rd::
	pushu   P4DR
	ld      r1,#00111111b           ; assert control write CS
	ld      P4DR,r1
	or      r1,#10000000b
	ld      P4DR,r1
	ld      r3,P4DR
	ld      r0,#01111111b
	ld      P4DR,r0
	ld      r0,r3           
	popu    P4DR
	ret


;****************************************
;********** put 8880 in POWER DOWN
;****************************************
_8880_pwd::
	push    P4DR
	ld      r1,P4DR
   and     r1,#~(O2)               ; pongo O2  a 0 
   or      r1,#CSN                 ; pongo CS* a 1 
	ld      P4DR,r1
	pop     P4DR
	ret


;****************************************
;********** scan for call progress tones
;****************************************
_8880_scancp::
	ld      r0,#DTMFTONE
	call    _8880_ctrl_wr
	
	ret
	

;****************************************
;****************** Attivazione VIVA VOCE
;****************************************
att_viva_voce::
	pushu   PPR
	spp     #P7D_PG
	ld      r0,P7DR
   or      r0,#(PD118 | PD119)     ; attiva MC34118 e MC34119
	ld      P7DR,r0
	popu    PPR
	ret


;****************************************
;*************** Disattivazione VIVA VOCE
;****************************************
disatt_viva_voce::
	pushu   PPR
	spp     #P7D_PG
	ld      r0,P7DR
   and     r0,#~(PD118 | PD119)    ; disattiva MC34118 e MC34119
	ld      P7DR,r0
	popu    PPR
	ret

;**************************************************************************
;****************** Sezione messaggistica vocale **************************
;**************************************************************************
cue_message::
	pushuw     rr0
	set_bit    P5DR,VOICE_CUE
   sleep      #100
	clr_bit    P5DR,VOICE_CUE
	popuw      rr0
	ret

reset_message::
	pushuw     rr0
	clr_bit    P5DR,VOICE_ADDR
   sleep      #100
	set_bit    P5DR,VOICE_ADDR
	popuw      rr0
	ret


rec_begin::
	pushu   PPR
	spp     #P7D_PG
;   pushuw     rr0
	clr_bit    P7DR,RECN
;   ldw        rr0,#40
;   loopw [rr0] {
;      sleep      #60
;   }
;   set_bit    P7DR,RECN
;  sleep      #60
;  waitnobit  P7DR,#RECLEDN
;   popuw      rr0
	popu    PPR
	ret

rec_end::
	pushu   PPR
	spp     #P7D_PG
;   pushuw     rr0
;   clr_bit    P7DR,RECN
;   ldw        rr0,#40
;   loopw [rr0] {
;      sleep      #60
;   }
	set_bit    P7DR,RECN
;  sleep      #60
;  waitnobit  P7DR,#RECLEDN
;   popuw      rr0
	popu    PPR
	ret


play_begin::
	pushu   PPR
	spp     #P7D_PG
;   pushuw     rr0
	clr_bit    P7DR,PLAYLN
;   ldw        rr0,#30
;   loopw [rr0] {
;      sleep      #60
;   }
;   set_bit    P7DR,PLAYLN
;  sleep      #60
	popuw      rr0
	popu    PPR
	ret

play_end::
	pushu   PPR
	spp     #P7D_PG
;   pushuw     rr0
;   clr_bit    P7DR,PLAYLN
;   ldw        rr0,#30
;   loopw [rr0] {
;      sleep      #60
;   }
	set_bit    P7DR,PLAYLN
;  sleep      #60
;   popuw      rr0
	popu    PPR
	ret

;**************************************************************************
;************************ Toni linea telefonica ***************************
;**************************************************************************

;****************************************
;************** Routine di riconoscimento
;****************************************

_tone_sample::
   spp     #0
;   ld      r0,#DTMFTONE
;   call    _8880_ctrl_wr

   ld      TONE_1,#0
   ld      TONE_0,#0

   sleep   #200

   while [TONE_0 < #36]
   {
     nop
   }

;   ld      r0,#DTMFINOUT
;   call    _8880_ctrl_wr
jezza::
   ld r1,TONE_1
   if [[TONE_1 > #11] && [TONE_1 < #15]]     ; 11-15 
   {
     ld       r0,#TONEDIAL
   }
   if [[TONE_1 > #17] && [TONE_1 < #22]]     ; 17-22
   {
     ld       r0,#TONEBUSY
   }
   if [TONE_1 > #26]                         ; 26+
   {
     ld       r0,#TONEPBX
   }
   if [TONE_1 < #6]
   {
     ld       r0,#TONEHIZ
   }
   
	ret


;**************************************************************************
;***************************** Telecomando ********************************
;**************************************************************************


;****************************************
;****************** Programmazione Timer0
;****************************************
T0_remote::        
	pushuw  RPP
	pushu   PPR
	srp     #(15*2)                         ; Set register bank F
	spp     #T0D_PG                         ; Set timer0 data page
   ld      t_tcr,  #00000000b              ; Set timer control reg
   ld      t_tmr,  #00000000b              ; Continuous/Retrigger mode
	ld      t_icr,  #00000000b              ; Set input control reg
   ld      t_idmr, #10000001b              ; Underflow interrupt
   ld      t_prsr,#3                       ; 1 uSec prescaler value
   ldw     t_reg0r,#1150                   ; 1150 uSec counter value 

	spp     #T0C_PG                         ; Set timer0 control page
   ld      t0_ivr,#MFT_IVR+2               ; Set int vector
   ld      t0_idcr,#00000001b              ; Set Timer T0 int level=1
	popu    PPR
	popuw   RPP
	ret

;****************************************
;*************** Campionamento principale
;****************************************
_frame_sample::
                                           ; time critical section begin
;   waitbit    P2DR,#REMOTE                ; depends on int triggering
   waitnobit  P2DR,#REMOTE                 ; depends on int triggering
   ldw        rr0,#frame_buffer            ; loads the frame buffer
	ldw        (rr0),#0                     ; zero the buffer
	ld         r2,#2                        ; 2 samples of 6 bits
	loop [r2] {                             ; 
	   ld         r4,#0                     ; zero the shift register
	   ld         r3,#6                     ; 
	   loop [r3] {                          ; single bit sample loop
	      delay      #320                   ; wait 390uS (to calibrate)
         ifbit P2DR,#REMOTE                ;
            ld         r5,#1               ; if level 1 r5 = 1
         } else {                          ;
            ld         r5,#0               ; else r5 = 0
         }                                 ;
         or         r4,r5                  ; add into shift register
	      rol        r4                     ; and shift left one bit
	      delay      #150                   ; wait 130uS (to calibrate)
	      waitnobit  P2DR,#REMOTE           ; wait for 0
	   }
      ld         (rr0),r4                  ; put shift reg into buffer
      incw       rr0                       ; increment buffer pointer
	}
	ret


;***********************************************************************
;************************** Gestione bus i2c ***************************
;***********************************************************************

;****************************************
;***************** Programmazione timer 0
;****************************************

proc T0_I2C [PPR]
{
stoppo::
	spp     #T0C_PG                         ; Set timer0 control page
   ld      T0_IVR,#MFT_IVR                 ; Set int vector
   ld      T0_IDCR,#00000010b              ; Set timer0 int level=x

	spp     #T0D_PG                         ; Set timer0 data page
   ld      T_TCR,  #00000000b              ; Set timer control reg
   ld      T_TMR,  #00000001b              ; Single/Retrigger mode
   ld      T_ICR,  #00000000b              ; Set input control reg
   ld      T_IDMR, #10000001b              ; Underflow interrupt
   ld      T_PRSR, #3                      ; 1 usec prescaler value
   ldw     T_REG0R,#5000                   ; 5 msec counter value
   decw    TOT_LENGHT
   while [CLZ] {
      addw    T_REG0R,#5000                ; 5 ms multiplied num. of bytes
      decw    TOT_LENGHT
	}	
   or      T_TCR,  #cen                    ; Start the timer0
}


;****************************************
;*********** I2C bus operations on slaves
;****************************************

proc i2c_bus [PPR]
{
i2cb::
   spp   #0
   spi_di
   ld    SLAVE_R,SLAVE_W                   ; Slave read/write slave
   or    SLAVE_R,#1
   ldw   TOT_LENGHT,LENGHT                 ; Save LENGHT before decrement.
   ifbit SLAVE_STAT,#SLAVE_READY           ; Test if bus is free
      switch [SLAVE_OP] {
         case  #READ:
            call     GEN_START             ; SPI and interrupt init
            ld       SPI_STAT,#TRANS_CTRL  ; Slave address
            ld       SLAVE_STAT,#LECT_ON   ; Start read condition
            ld       SPIDR,SLAVE_W         ; write mode address
         case  #VERIFY:
            call     GEN_START             ; SPI and interrupt init
            ld       SPI_STAT,#TRANS_CTRL  ; Slave address
            ld       SLAVE_STAT,#VERIF_ON  ; Start verify condition
            ld       SPIDR,SLAVE_R         ; read mode address
         case  #WRITE:
            call     GEN_START             ; SPI and interrupt init
            ld       SPI_STAT,#TRANS_CTRL  ; Slave address
            ld       SLAVE_STAT,#ECR_ON    ; Start write condition
            ld       SPIDR,SLAVE_W         ; write mode address
      }
   }
}

;****************************************
;************* START condition generation
;****************************************
proc GEN_START [PPR]
{
   spp      #0                         ; SPI and ext. ints. in page 0.
   and      SPICR,#~spen               ; Disable SPI -> SDA, SCK in HZ
;   ld       SPICR,#(bms | SPI_128)    ; Disable SPI -> SDA, SCK in HZ
   and      P2DR,#~SDO                 ; Prepare "0" on output buffer of SDO.
   spp      #P2C_PG
   and      P2C0R,#~SDO                ; SDO line in output -> SDA line = "0".
   delay    #3                         ; Wait for start condition hold time.
   spp      #0
   or       SPICR,#spen                ; Enable SPI.
   nop
   spi_ei                              ; Enable SPI interrupt.
   spp      #P2C_PG
   or       P2C0R,#SDO                 ; SDO line in AF.
}

;****************************************
;************** STOP condition generation
;****************************************
proc GEN_STOP [PPR]
{
   spp      #0
   spi_di                              ; Disable SPI interrupt.
   and      P2DR,#~SDO                 ; Prepare "0" on output buffer of SDO.
   spp      #P2C_PG
   and      P2C0R,#~SDO                ; SDO line in output -> SDA line = "0".
   spp      #0 
   and      SPICR,#~spen               ; Disable SPI -> SCK line = "1".
   delay    #3                         ; Wait for stop condition setup.
   spp      #P2C_PG
   or       P2C0R,#SDO                 ; SDO in AF -> SDA line = "1".
}

;****************************************
;***** ACK pulse generation and force SDA
;****************************************
proc GEN_ACK [PPR]
{
   and      P2DR,#~SDO                 ; Prepare "0" on output buffer of SDO.
   spp      #P2C_PG                    
   and      P2C0R,#~SDO                ; SDO line in output -> SDA line = "0".
   spp      #0 
   and      SPICR,#~spen               ; Disable SPI -> SCK line = "1".
   delay    #3                         ; Wait for ACK hold time.
   or       SPICR,#spen                ; Enable SPI -> Force SDA and SCK low.
   spp      #P2C_PG
   or       P2C0R,#SDO                 ; SDO line in AF.
}

;****************************************
;*** ACK pulse generation and slave check
;****************************************
proc TEST_ACK [PPR]
{
   and     SPICR,#~spen                ; Release SPI lines in disabling it.
   waitbit P2DR,#SCK                   ; Wait for SCK going high.
   ifbit   P2DR,#SDI                   ; Check if receiver has acknowledged.
      ld      SLAVE_STAT,#NO_ACK       ; If no ACK 
   } else {  
      delay   #3                       ; Wait for high period of the clock.
   } 
   or SPICR,#spen                      ; Enable SPI -> Force SDA low.
}

;**************************************************************************
;***************************** Routines varie *****************************
;**************************************************************************

proc clock [PPR,r0,r1,r2,r3,r4,r5,r6,r7]
{
   i2c     READ,RTC_SLAVE,#0,#4

   ldw     rr6,#0
   ldw     rr4,#15
   loopw [rr4] {
      ifw [line2(rr4) == #2323h]
      {
         ld    r0,i2c_buffer(rr6)
         incw  rr6

cicco::
         byte2bcd r0,r2,r1

         bcd2ascii r1,r1
         bcd2ascii r2,r2
         ld    line2+1(rr4),r1
         ld    line2(rr4),r2
      }
   }
}

;**************************************************************************
;************************** Dati statici in rom ***************************
;**************************************************************************

;                        .org    SDATA
id::                    .asciz  "TS FW.05B Tuccia"

;****************************************
;**************** Messaggi per il display
;****************************************

message_open::          .asciz  "    PT117/96    "
message_name::          .asciz  "Nova Elettra srl"
message_diag::          .asciz  "  AUTODIAGNOSI  "
message_attenzione::    .asciz  "Hard Ok  Soft Ok"
message_ok::            .asciz  "   INOLTRATO    "
message_ready::         .asciz  "Nova PT117 FW0.5"
message_time::          .asciz  "  ORE ##:##:##  "
message_alarm::         .asciz  "Allarme in corso"
message_alrem::         .asciz  "da telecomando  "
message_altrig::        .asciz  "da pulsante     "
message_altime::        .asciz  "per fine tempo  "
message_break::         .asciz  "   ANNULLATO    "
message_attendere::     .asciz  "attendere prego."

message_call::          .asciz  "Composizione del"
message_noresp::        .asciz  ""
message_resp::          .asciz  "Risponde il num."
                                   
message_progst::        .asciz  " Programmazione "
message_tastipr::       .asciz  " *~  # Conferma "
message_tastibegin::    .asciz  "Alzare cornetta!"
message_tastiend1::     .asciz  "    Alla fine   "
message_tastiend2::     .asciz  "  riagganciare. "
message_fineprog1::     .asciz  " Programmazione "
message_fineprog2::     .asciz  "   terminata.   "
menu_oradata::          .asciz  "   Ora / Data  ~"
menu_messaggi::         .asciz  "   Messaggi   ~"
menu_numeri::           .asciz  "  Numeri Tel. ~"
menu_telecomando::      .asciz  " Telecomando  ~"
menu_tempi::            .asciz  "    Tempi     ~"
menu_riservato::        .asciz  "  Riservato    "
sub_oradata1::          .asciz  "Non disponibile!"
sub_oradata2::          .asciz  " *             "
sub_messaggi1::         .asciz  "Nuovo messaggio "
sub_messaggi2::         .asciz  " *  # Registra "
sub_numeri1::           .asciz  "  Numeri Tel. ~"
sub_numeri2::           .asciz  " *  # Conferma "
sub_telecomando1::      .asciz  " Telecomando  ~"
sub_telecomando2::      .asciz  " *             "
sub_tempi1::            .asciz  "    Tempi     ~"
sub_tempi2::            .asciz  " *             "
sub_riservato1::        .asciz  "  Riservato    "
sub_riservato2::        .asciz  " *             "
messaggi_begin1::       .asciz  "  Parlare nel   "
messaggi_begin2::       .asciz  " microfono....  "
messaggi_end1::         .asciz  "   Messaggio    "
messaggi_end2::         .asciz  "  registrato.   "
numeri_begin1::         .asciz  "  1o Numero:    "

message_cornetta::      .asciz  "Cornetta telef. "
message_abbassata::     .asciz  "   ABBASSATA    "
message_alzata::        .asciz  "     ALZATA     "

malvenuto::             .asciz  "Guarda i numeri:"
telesoccorso::          .asciz  "Il telesoccorso:"
telecomando::           .asciz  "Il telecomando: "

msgtony::               .asciz  "Linea telefonica"
msgoccupato::           .asciz  "    OCCUPATA    "
msglibero::             .asciz  "     LIBERA     "
msgpbx::                .asciz  "   PBX LIBERO   "
msghiz::                .asciz  " ALTA IMPEDENZA "

;numero::                .byte   10,3,3,8,8,2,8,2,8,1,1,0
;numero::                .byte   10,3,3,6,4,6,10,1,8,5,0

;numero::                .byte   1,1,0
num2::                   .byte   1,2,3,4


;**************************************************************************
;****************** Definizione dei dati dinamici in RAM ******************
;**************************************************************************
    
   .data
;   .org    0

;//////////////////////// per usare emulatore /////////////////
   .org 200h
;//////////////////////////////////////////////////////////////

display_buffer::
line1::                 .blkb   16              ; display buffer of 32 char
line2::                 .blkb   16

frame_buffer::          .blkw   2               ; format: 0xxxxxx00xxxxxx0

combtel_buffer::        .blkb   32              ; buffer of 32 numbers

                        .blkb   64
i2c_buffer::            .blkb   64              ; buffer for i2c bus

time_buffer::           .blkb   6               ; buffer for real time clock

numero::                .blkb   16      
