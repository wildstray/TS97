;************************************************************************** 
;*                                                                        *
;* FILE NAME:   Nova.st9                                                  *
;*                                                                        *
;* DESCRIPTION: Firmware for TELESOCCORSO                                 *
;*                                                                        *
;* CONTENTS:    * Simbols and numerical equivalences                      * 
;*              * Internal registers variables allocations                * 
;*              * ST9 configuration code                                  *
;*              * MAIN procedure                                          *
;*              * RTC procedure                                           *
;*              * Interrupt service procedures                            *
;*              * Subroutine                                              *
;*              * Data section define                                     *
;*                                                                        *
;* VERSION                : 0.1.0                                         *
;*                                                                        *
;*                                                                        *
;* FILE ORIGINAL DATE     : 09/04/97                                      *
;*                                                                        *
;* AUTHOR                 : Andrea Tuccia                                 *
;*                                                                        *
;**************************************************************************




.title          "TS firmware"
.pl             66                      ; number of lines per page
.list           me                      ; enable macro expansion control
.page




;***************************************
;*********************** Include section
;***************************************
;*
;* The following section include the standard 
;* symbols for the ST90T28
;*
;***************************************
.nlist             
.include    "c:\st9\include\system.inc"    ; System register
.include    "c:\st9\include\page_0.inc"    ; Page 0 register
.include    "c:\st9\include\io_port.inc"   ; I/O port register
.include    "c:\st9\include\mftimer.inc"   ; MF Timer register
.include    "c:\st9\include\ad_c.inc"      ; A/D converter register
.include    "c:\st9\include\sci.inc"       ; SCI register
.include    "c:\st9\include\bitmacro.inc"  ; BIT macros
.list




;**************************************************************************
;***************************** MACRO SECTION ******************************
;**************************************************************************
.include        "nova.mac"

;***************************************
;**************************** macro list 
;***************************************
;* set_bit              dest,#mask
;* clr_bit              dest,#mask     
;* cpl_bit              dest,#mask
;* ld_mm                dst,src         ; memory to memory byte load
;* ldw_mm               dst,src         ; memory to memory word load
;* clrw                 op              ; clear word
;* cpl2_w               wr              ; 2 complement word
;* start_T0_timer
;* stop_T0_timer
;* rdwr_data_to_SPI                     ; r0->SPI SPI->r0
;* read_P7DR                            ; P7DR->r0
;* write_P7DR                           ; r0->P7DR
;* enable_RX_int
;* disable_RX_int
;* enable_TX_int
;* disable_TX_int
;* delay                us              ; delay of xxxxx us



;**************************************************************************
;******************** Simbols and numerical equivalences ******************
;**************************************************************************
;SSP_VAL                 = 223           ; bank D C
;USP_VAL                 = 191           ; bank B


;//////////////////////// per usare emulatore///////////////////
;                                       ; D   EMULATORE
SSP_VAL                 = 207           ; bank C B
USP_VAL                 = 175           ; bank A
;//////////////////////// per usare emulatore///////////////////


;***************************************
;********* text section absolute address
;***************************************
START_IT_TABLE  = 0                     ; Start of interrupt vector table
SCI_VEC         = 040h                  ; Start SCI int vector
EXT_INT_VEC     = 050h                  ; External interrupt base vector
T0_UNDERFLOW    = 0C0h                  ; T0 int vector
START_CODE      = 100h                  ; Start of C startup code


;**************************************************************************
;**************** Internal register variable allocations ******************
;**************************************************************************

;**************
;* Bank C end D             
;**************
; Used for SSP


;**************
;******* Bank B             
;**************
; Used for USP


;**************
;******* Bank A             
;**************
;       := RR174 \
;       := RR172  | 
;       := RR170  |
;       := RR168  | Non usare con emulatore
;       := RR166  |
;       := RR164  |
;       := RR162  |
;       := RR160 /


;**************
;******* Bank 9                       
;**************
;        := RR158                     
;        := RR156                     
;        := RR154                     
;        := RR152                     
;        := RR150                     
;        := RR148                     
;        := RR146                     
;        := RR144                     

					
		
;**************
;******* Bank 8             
;**************
;       := RR142
;       := RR140
;       := RR138
;       := RR136
;       := RR134
;       := RR132
;       := R131
;       := R130
;       := R129 
;       := R128 


;**************
;******* Bank 7             
;**************
;       := RR126
;       := R125
;       := R124
;       := R123
;       := R122
;       := R121
;       := R120
;       := R119 
;       := R118
;       := R117 
;       := R116 
;       := R115 
;       := R114 
;       := R113 
;       := R112 
					

;**************
;******* Bank 6             
;**************
;       := RR110
;       := RR108
;       := RR106
;       := RR104
;       := RR102
;       := R101
;       := R100
;       := R99
;       := R98  
;       := R97  
;       := R96  



;**************
;******* Bank 5             
;**************
;       :=RR94
;       :=R93
;       :=R92
;       :=R91
;       :=R90
;       :=RR88
;       :=RR86
;       :=RR84
;       :=RR82
;       :=RR80



;**************
;******* Bank 4             
;**************
;       :=R79
;       :=R78
;       :=RR76
;       :=RR74
;       :=RR72
;       :=RR70
;       :=RR68
;       :=RR66
;       :=RR64



;**************
;******* Bank 3                         ; Timer0 context registers
;**************
;       :=RR62                          ; Don't define!
;       :=RR60
;       :=RR58
;       :=RR56
;       :=RR54
;       :=RR52
;       :=RR50
;       :=RR48



;**************
;******* Bank 2                         ; WatchDog context registers
;**************
;       :=RR46                          ; Don't define!
;       :=RR44
;       :=RR42
;       :=RR40
;       :=RR38
;       :=RR36
;       :=RR34
;       :=RR32



;**************
;******* Bank 1                         ; Page #1 context register
;**************
;       :=RR30                          ; Don't define!
;       :=RR28                           
;       :=RR26                          
;       :=RR24
;       :=RR22
;       :=RR20
;       :=RR18
;       :=R17
;       :=R16








;**************************************************************************
;************************ TS INITIALIZATIONS CODE  ************************
;**************************************************************************
   .text                                   ; Start program segment


;***************************************
;**************** Interrupt vector table
;***************************************


   .org    START_IT_TABLE
	.word   st9$entry                       ; Reset interrupt vector:Entry point
	.word   _trap_div0                      ; Divide by 0 interrupt service routine
	.word   _top_level_int                  ; Top Level interrupt service routine
	;***********************        
   .org    SCI_VEC
   .word   _SCI_it_s_rec_err               ; SCI receiver err int service
	.word   _SCI_9th_bit                    ; SCI 9th bit int service
   .word   _SCI_it_receive                 ; SCI RX int service
   .word   _SCI_it_transmit                ; SCI TX int service
	;***********************        
   .org    EXT_INT_VEC                             
   .word   _A0_int                         ; Interrupt A0 ( Watchdog )
   .word   _A1_int                         ; Interrupt A1 ( 8880 IRQ )
   .word   _B0_int                         ; Interrupt B0 ( SPI int  )
   .word   _B1_int                         ; Interrupt B1 ( Remote   )
   .word   _C0_int                         ; Interrupt C0 ( External )
   .word   _C1_int                         ; Interrupt C1 ( External )
   .word   _D0_int                         ; Interrupt D0 ( External )
   .word   _D1_int                         ; Interrupt D1 ( External )
	;***********************        
   .org    T0_UNDERFLOW
   .word   _T0_int_0                       ; Multifunction timer interrupt
   .word   _T0_int_1                       ; Multifunction timer interrupt
   .word   _T0_int_2                       ; Multifunction timer interrupt
   .word   _T0_int_3                       ; Multifunction timer interrupt
	;***********************        



;***************************************
;************ Linker options entry point
;***************************************
   .org    START_CODE                           ; Start code
	;***********************        
st9$entryRS::                                   ; Entry point for Separate 
   sdm                                          ; Read Only Environment -iI
	;***********************        
st9$entryR_::                                   ; Entry point for 
   or      FLAGR,#10b                           ; Read Only Environment -I 
   jr      st9$entry_GO                         ; Set user flag:
                                                ; data (ROM) to bss (RAM) copy
	;***********************        
st9$entry_S::                                   ; Entry point for Separate
   sdm                                          ; Address Space -i
	;***********************        
st9$entry__::                                   ; Entry point for 
   and     FLAGR,#~10b                          ; Common Address Space
st9$entry_GO::                                  ;


;**************************************************************
;** P0X EQUATES ( P4X EMULATED )
RWN             = 00010000b
RS0             = 00100000b
CSN             = 01000000b
O2              = 10000000b

;** P1X EQUATES ( P7X EMULATED / SHIFTED LEFT 2 )
ENABLE          = 00000100b ;(00000001b)
PLAYLN          = 00001000b ;(00000010b)
RECN            = 00010000b ;(00000100b)
RECLEDN         = 00100000b ;(00001000b)
PD118           = 01000000b ;(00010000b)
PD119           = 10000000b ;(00100000b)

;** P2X EQUATES ( P2X EMULATED )
BACKLIGHT       = 00000001b
DTMFCP          = 00010000b
LED1            = 00100000b
LED2            = 01000000b
REMOTE          = 10000000b

;** P5X EQUATES ( P5X EMULATED )
MUTE            = 00000001b
REL1            = 00000010b
REL2            = 00000100b
RING            = 00001000b
VOICE_CUE       = 00010000b
VOICE_ADDR      = 00100000b

;** MT8880 EQUATES
DTMFAVLB        = 00000100b
DTMFINOUT       = 00000101b
DTMFTONE        = 00000110b
TONEDIAL        = 1
TONEPBX         = 2
TONEBUSY        = 3
TONEMISDIAL     = 4

;EXTERNAL ALARMS
ALARM1          = 10000000b
ALARM2          = 01000000b
ALARM3          = 00100000b
ALARM4          = 00010000b


;**************************************************************


;***************************************
;************************* Init I/O port 
;***************************************
Init_IO_port:

	srp     #(15*2)                         ; Enable bank register 15
	spp     #2                              ; Enable page 2
       
	ld      p2c2r,#10001111b                ;\ 
	ld      p2c1r,#01101110b                ; | Set port 2
	ld      p2c0r,#11011111b                ;/
       
  ;emulator board  ^     ^

	ld      p2dr,#00000000b
	;***********************
	ld      p3c2r,#11111100b                ;\ 
	ld      p3c1r,#11110011b                ; | Set port 3
	ld      p3c0r,#11111111b                ;/
	;***********************
	spp     #3
	;***********************
	ld      p4c2r,#00000000b                ;\ 
	ld      p4c1r,#11110000b                ; | Set port 4
	ld      p4c0r,#00000000b                ;/
	ld      p4dr ,#00000000b
	;***********************
	ld      p5c2r,#00001000b                ;\
	ld      p5c1r,#11110111b                ; | Set port 5
	ld      p5c0r,#00001000b                ;/ 
	ld      P5DR ,#00100000b
	;***********************
	ld      p7c2r,#00100001b                ;\
	ld      p7c1r,#11011110b                ; | Set port 7
	ld      p7c0r,#00100011b                ;/ 
	;***********************
	ld      P7DR ,#00111111b



;***************************************
;********* system register configuration 
;***************************************
	srp     #(14*2)                         ; Set register bank E
	spp     #0                              ; Init page pointer register
	ld      moder,#11100000b                ; Set USP,SSP in int reg - Ck/2
	ld      usplr,#(USP_VAL+1)              ; Init User stack pointer
	ld      ssplr,#(SSP_VAL+1)              ; Init System stack pointer
;  ld      cicr,#10001111b                 ; Set CICR   OK
;////////////////////// per usare emulatore ////////////////
	ld      cicr,#10101111b                 ; Set CICR   OK
;///////////////////////////////////////////////////////////
	and     flagr,#03h                      ; Clr flag register

							  


;***************************************
;****************** page 0 configuration 
;***************************************
	srp     #(15*2)                         ; Set register bank F
   ld      eimr,#00000001b                 ; Unmask interrupts
   ld      eitr,#10000000b                 ; Set int triggers
	ld      eivr,#01010100b                 ; Set int_vect=5X / NMI
   ld      eiplr,#10101001b                ; Interrups priority
;  ld      nicr,#00000000b                 ; TLI disabled   
;////////////////////// per usare emulatore ////////////////
	ld      nicr,#10000000b                 ; TLI enabled
;///////////////////////////////////////////////////////////
	clr     eipr                            ; Clear ext pending int.
	ld      wcr,#01000000b                  ; Disable WatchDog

;tuccia riguardare la parte sovrastante ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^



;***************************************
;****************************** init SCI
;***************************************
	spp     #SCI1_PG                        ; Set SCI page register
	ld      s_brghr,#00                     ; Set baud_rate=19.200
	ld      s_imr,#00h                      ; Set int mask register
	ld      s_ivr,#SCI_VEC                  ; SCI interrupt vector
                                           ;  40h=Rx error
                                           ;  42h=9th bit address 
						
                                           ;  44h=Rx data ready
                                           ;  46h=Tx data empty 
	ld      s_idpr,#00h                     ; Set interrupt priority=2
	ld      s_chcr,#06Bh                    ; Set char conf register
                                           ;  8 bit data
                                           ;  2 bit stop
                                           ;  parity enabled
                                           ;  even parity
	ld      s_ccr,#082h                     ; Set clock conf register
                                           ;  16 * asynchronous mode
                                           ;  en loop back
	and     s_isr,#03h                      ; Clr pending interrupt
	ld      s_brglr,#39                     ; Set baud_rate=19.200 (24Mhz)


;***************************************
;******************************* init WD
;***************************************
	spp     #WDT_PG                         ; Set Watch_dog timer page
	ld      wdtpr,#29                       ; Prescaler value
   ldw     wdtr ,#5000                     ; Number to count 
	ld      wdtcr,#00110000b                ; Continuous mode / Timer
	


;***************************************
;****************************** init SPI
;***************************************
	spp     #SPI_PG                         ; Set SPI page
	ld      spicr,#01000010b                ; Enable SPI
                                           ; Reset Busy flag
                                           ; set clock phase
                                           ; speed max
                                           ; output disabled



;***************************************
;******************** Serial line enable
;***************************************
;* Send a dummy char at power up
;* to set a correct state of TXempty flag.
;**************

	srp     #0                              ; Set register bank 0
	;***********************
	spp     #SCI1_PG                        ; Set SCI page register
	ld      S_TXBR,#0AAh                    ; Trasmit dummy char
	;***********************
	delay   #2000                           ; Delay to end tx
	;***********************                
	and     S_ISR,#00000011b                ; Clear pending bit
	ld      S_CCR,#80h                      ; Disable loop back mode
   ld      s_idpr,#00001000b

;**************************************************************************
;************************** TS MAIN PROGRAM *******************************
;**************************************************************************
main::
	srp     #(15*2)                         ; Set register bank F
	spp     #WDT_PG                         ; Set Watch_dog timer page
   or      wdtcr,#stsp                     ; Start WatchDog/Timer
	
	spp     #0                              ; Set Page 0
	srp     #0                              ; Set register bank 0
	call    display_init
	call    _8880_init
  ;start_T0_timer
	
	ei
	
xxx::
	nop
	nop
	;//////////////////////////////////////////
	; set display buffer for test
	;
	ldw     rr0,#display_buffer
	ldw     rr2,#benvenuto
	ld      r4,#32
	loop [r4] {
	   lddd (rr0)+,(rr2)+
	}
	;//////////////////////////////////////////

	;call     att_viva_voce

;jx xyz
	set_bit P5DR,REL1       ;on hook
   set_bit P5DR,REL2       
	delay   #60000
	delay   #60000
	
eee::        
	
;  or      EIMR,#(ALARM1 | ALARM2 | ALARM3 | ALARM4)
;  clr     eipr  
	
   jx      tony

xyz:: 
;       attendo ring per prendere linea
	loop {
	   ifnobit P5DR,#RING    ;ring se bit == 0
	      set_bit P5DR,REL1       ;on hook
	      break
	   }
	}

xxx1::
;////////////////////////////////////////////////////////////////////////



	or      P5DR,#8
	ldw     rr0,#0fffh
	loopw [rr0] {
	   delay   #60
	}


;  ld      r0,#DTMFTONE
	ld      r0,#DTMFINOUT
	call    _8880_ctrl_wr


cazzillo::
;        loop {
;           ifbit   P2DR,#TONE
;              clr_bit   P5DR,REL1
;           }
;        do {
;                nop
;                call    _8880_ctrl_rd
;                nop
;                ld      r1,r0
;                and     r0,#00000010b
;        } while [r0 == #0] 
;
;        }
;        ld      r0,#DTMFINOUT
;        call    _8880_ctrl_wr
;        delay   #8000


zzz:: 


	;******
	ld      r0,#1111b
	call    _8880_ctrl_wr
	ld      r0,#0000b
	call    _8880_ctrl_wr
	;******
	ld      r0,#10     ;**** cifra 1
	call    _8880_data_wr        
	;******
	do {
		nop
		call    _8880_ctrl_rd
		nop
		ld      r1,r0
		and     r0,#00000010b
	} while [r0==#0] 

	delay   #60000
	delay   #60000
	delay   #60000
	delay   #60000
	delay   #60000
	delay   #60000
	delay   #60000
	delay   #60000
	delay   #60000

	;******
	ld      r0,#1111b
	call    _8880_ctrl_wr
	ld      r0,#0000b
	call    _8880_ctrl_wr
	;******
	ld      r0,#10     ;**** cifra 1
	call    _8880_data_wr        
	;******
	do {
		nop
		call    _8880_ctrl_rd
		nop
		ld      r1,r0
		and     r0,#00000010b
	} while [r0==#0] 
;  and    r1,#00000100b
;  if [r1!=#0] {
;     call    _8880_data_rd
;  }
	jx      pino

       
loop {
	delay  #30000

	ld      r0,#7    ;**** cifra 2
	call    _8880_data_wr        
	;******
	do {
		nop
		call    _8880_ctrl_rd
		nop
		ld      r1,r0
		and     r0,#00000010b
	} while [r0 == #0] 
;  and    r1,#00000100b
;  if [r1!=#0] {
;     call    _8880_data_rd
;  }
}

pino::

;  ld      r0,#DTMFTONE
	ld      r0,#DTMFINOUT
	call    _8880_ctrl_wr


	call    display_bufclr

	ldw     rr6,#display_buffer
	ldw     rr2,#malvenuto
	ld      r4,#16
	loop [r4] {
	   lddd (rr6)+,(rr2)+
	}
	xor     r8,r8


peppo::        
	
	
	loop {
	   delay   #8000
	   call    _8880_ctrl_rd
	   ifbit   r0,#DTMFAVLB            ;ricevuta cifra DTMF ?
	      delay   #8000
	      call    _8880_data_rd
	      delay   #8000
	      ld   r2,r0
	      inc  r8
	      if [r8 > #16] {
            xor     r8,r8
            inc     r8
            ldw     rr6,#display_buffer
            addw    rr6,#16
	      }
	      switch [r0] {
	      case #0:
            break
	      case #10:
            ld      r4,#48
            ld      (rr6)+,r4
            call    reset_message
	      case #11:
            ld      r4,#00101010b
            ld      (rr6)+,r4
            call    rec_message
	      case #12:
            ld      r4,#00100011b
            ld      (rr6)+,r4
            call    play_message
	      default:
            ld      r4,#48
            add     r4,r2
            ld      (rr6)+,r4
	      }
	   }
	}

	call    _8880_scancp
	switch [r0] {
	   default:
	}
	
stop::
	jx      stop



rem::
;   call    T0_remote
   call    display_bufclr
	ldw     rr0,#display_buffer
	ldw     rr2,#telecomando
	ld      r4,#16
	loop [r4] {
	   lddd (rr0)+,(rr2)+
	}             
	loop {
      waitbit P2DR,#REMOTE
      call    _frame_sample
      ldw     rr6,#display_buffer+16
      ldw     rr8,(frame_buffer)
      ld      r1,#16
      loop [r1] 
      {
         ld      r2,#48
         ifbitw  rr8,#1000000000000000b
            ld      r2,#49
         }
         rlcw    rr8
         ld      (rr6)+,r2
      }
	}


tony::
   ld      r0,#DTMFTONE
	call    _8880_ctrl_wr

   call    T0_cptone
   call    display_bufclr
	ldw     rr0,#display_buffer
   ldw     rr2,#msgtoni
	ld      r4,#16
	loop [r4] {
	   lddd (rr0)+,(rr2)+
	}             

   set_bit P5DR,REL1       ;on hook
   clr_bit P5DR,REL2       

   loop {
      
	}


user_main::

	nop
	nop
	jx      user_main


;**************************************************************************
;********************** INTERRUPT SERVICE ROUTINES ************************
;**************************************************************************


;***************************************
;************************ T0 interrupt 0
;***************************************
_T0_int_0::
	pushw   RPP                             ; Save RPP
	push    PPR                             ; Save PPR
   srp     #(8*2)                          ; Switch context
   ;***********************                
   spp     #T0D_PG                         ; Enable Timer_0 page
   and     T_FLAGR,#~(ouf | cp0 | cp1)     ; Clear Overflow/Underflow/Capture
	spp     #0
	;***********************

   or      P5DR,#1
   delay   #20
   and     P5DR,#~1

	;***********************                
	pop     PPR                             
	popw    RPP                             ; Restore context    
	iret                                    


;***************************************
;************************ T0 interrupt 1
;***************************************
_T0_int_1::
   iret

;***************************************
;************************ T0 interrupt 2
;***************************************
_T0_int_2::
   iret

;***************************************
;************************ T0 interrupt 3
;***************************************
_T0_int_3::
   iret





;***************************************
;**************************** _trap_div0
;***************************************
_trap_div0::                                    ; Divide by 0 interrupt service routine
	ret




;***************************************
;******************* Top level interrupt
;***************************************
_top_level_int::                                ; Top Level interrupt service routine
	iret



;***************************************
;****************** SCI errors interrupt
;***************************************
_SCI_it_s_rec_err::
	iret




;***************************************
;***************** SCI 9th bit interrupt
;***************************************
_SCI_9th_bit::
	iret
	



;***************************************
;**************** SCI TX empty interrupt
;***************************************
_SCI_it_transmit::
	iret




;***************************************
;********************* SCI RX interrupt
;***************************************
_SCI_it_receive::
	iret



;***************************************
;******************** WD timer int 50ms
;***************************************
_A0_int::
	pushw   RPP                             ; Save RPP
	push    PPR                             ; Save PPR
   srp     #(9*2)                          ; Switch context  
	spp     #0
   clr     EIPR
   ;***********************
   call    display_update
	;***********************                
	pop     PPR                             
	popw    RPP                             ; Restore context    
	iret

;***************************************
;**************************** MT8880 IRQ
;***************************************
_A1_int::
    iret

;***************************************
;************************* SPI Interrupt
;***************************************
_B0_int::
	 iret

;***************************************
;******** external or Software interrupt
;***************************************
_B1_int::
	 iret

_C0_int::
_C1_int::
_D0_int::
_D1_int::
	pushw   RPP                             ; Save RPP
	push    PPR                             ; Save PPR
   srp     #(8*2)                          ; Switch context
   clr     EIPR

   or      P5DR,#1
   delay   #20
   and     P5DR,#~1

	pop     PPR                             
	popw    RPP                             ; Restore context    
	iret                                    



	 pushw   RPP                             ; Save RPP
	 push    PPR                             ; Save PPR
	 pushw   rr0                             
	 pushw   rr2                             
	 pushw   rr4                             
	 
	 srp     #0                              ; Set register bank 0
	 spp     #0
	 clr     eipr
	 ;and     EIMR,#~(ALARM1 | ALARM2 | ALARM3 | ALARM4)
	 
	 sdm
	 ldw     rr0,#display_buffer
	 ldw     rr2,#telesoccorso
	 ld      r4,#16
	 loop [r4] {
	    lddd (rr0)+,(rr2)+
	 }
	 ldw     rr2,#aiuto
	 ld      r4,#16
	 loop [r4] {
	    lddd (rr0)+,(rr2)+
	 }
	 
	 popw    rr4                             
	 popw    rr2                             
	 popw    rr0                             
	 pop     PPR
	 popw    RPP                             
	 iret
	 nop




;**************************************************************************
;******************************** DISPLAY *********************************       
;**************************************************************************

				    
;***************************************
;************************** init display
;***************************************
display_init::
	ld      P4DR,#01001111b                 ; scrittura istruzioni
	;***********************    
	ld      r0,#00110000b                   ;\
	call    _display_nibble_wr              ; |
	delay   #4000                           ; | 
	ld      r0,#00110000b                   ; |
	call    _display_nibble_wr              ; | display software reset
	delay   #100                            ; | 
	ld      r0,#00110000b                   ; |
	call    _display_nibble_wr              ; |
	delay   #100                            ;/
	;***********************
	call    _display_ready
	ld      r0,#00100000b                   
	call    _display_nibble_wr              ; set interface to 4 bit
	;***********************
	call    _display_ready
	ld      r0,#00101000b                   ; set 2 lines, 5*7 font
	call    _display_write
	;***********************
	call    _display_ready
	ld      r0,#00001000b                   ; display off
	call    _display_write
	;***********************
	call    _display_ready
	ld      r0,#00001110b                   ; display on
	call    _display_write
	;***********************
	call    _display_ready
	ld      r0,#00000110b                   ; entry mode set
	call    _display_write

	ret




;***************************************
;************************ display update
;***************************************

display_return::
	call    _display_ready
   ld      P4DR,#01001111b                   ; set_dis_inst_wr_mode
   ld      r0,#00000010b                     ; return home
	call    _display_write
	ret

display_bufclr::
	ldw     rr8,#display_buffer
   ld      r10,#32                           ; loop write 32 char
	ld      r11,#00100000b
   loop [r10] {                              ; fill display buffer
      ld      (rr8)+,r11                     ; with spaces
	}
	ret

display_update:
	pushuw  rr0
	pushuw  rr2
	pushuw  rr8
	pushuw  rr10
	;***********************
	call    _display_ready
   ld      P4DR,#01001111b                   ; scrittura istruzioni
   ld      r0,#10000000b                     ; first line (set address)
	call    _display_write
	;***********************
	ldw     rr8,#display_buffer
	ld      r10,#16
   loop [r10] {                              ; loop 16 times (a line)
		call    _display_ready
      ld      P4DR,#01101111b                ; scrittura dati
		ld      r0,(rr8)+
		call    _display_write
	}
	;***********************
	call    _display_ready
   ld      P4DR,#01001111b                   ; scrittura istruzioni
   ld      r0,#11000000b                     ; second line (set address)
	call    _display_write
	;***********************
	ld      r10,#16
   loop [r10] {                    ; loop 16 times (a line)
		call    _display_ready
      ld      P4DR,#01101111b      ; scrittura dati
		ld      r0,(rr8)+
		call    _display_write
	}
	popuw   rr10
	popuw   rr8
	popuw   rr2
	popuw   rr0
	;*********************** 
	ret



;***************************************
;****************** display nibble write
;***************************************
_display_nibble_wr::
	pushu   PPR
	spp     #P7D_PG
	;***********************
	or      P7DR,#00000100b         ; set bit 2
	;*********************** 
	swap    r0
	and     r0,#00001111b
	ld      r2,P4DR
	and     r2,#11110000b             
	or      r0,r2
	ld      P4DR,r0                 ; write
	;***********************
	and     P7DR,#11111011b         ; reset bit 2
	;***********************
	popu    PPR                 
	ret

;***************************************
;******************* display nibble read
;***************************************
_display_nibble_rd::
	pushu   PPR
	spp     #P7D_PG                 
	;***********************
	or      P7DR,#00000100b         ; set bit 2
	nop
	and     P7DR,#11111011b         ; reset bit 2
	;***********************
	nop
	ld      r0,P4DR                 ; read
	and     r0,#00001111b
	swap    r0
	;*********************** 
	popu    PPR                 
	ret


;***************************************
;******************** display char write
;***************************************
_display_write::
	pushu   r0
	call    _display_nibble_wr
	popu    r0
	swap    r0
	call    _display_nibble_wr
	ret

;***************************************
;******************** display char write
;***************************************
_display_read::
	call    _display_nibble_rd
	ld      r1,r0
	call    _display_nibble_rd
	swap    r0
	or      r1,r0
	ld      r0,r1
	ret

;***************************************
;******************** is display ready ?
;***************************************
_display_ready:: 
	pushu   P4DR
	spp     #P7D_PG                 
	;***********************
	ld      P4DR,#01011111b         ; modo instruzioni & read
	;***********************
	ldw     rr2,#10000              ; prova 10000 volte
	loopw [rr2] {
	   call    _display_read
      ifnobit r0,10000000b         ; controlla il BF
	      break
	   }
	}
	popu    P4DR
	ret


;**************************************************************************
;******************************** EEPROM **********************************       
;**************************************************************************



;***************************************
;*************** Write data to EEPROM #1
;***************************************
wr_data_to_E1::
;  set_CSE1
	ld      r0,#1b
	rdwr_data_to_SPI
	ld      r0,#01000000b
	rdwr_data_to_SPI
	ld      r0,#55h
	rdwr_data_to_SPI
;  rst_CSE1
	ret



;***************************************
;*************** Read data to EEPROM #1
;***************************************
rd_data_from_E1::
;  set_CSE1
	ld      r0,#1b
	rdwr_data_to_SPI
	ld      r0,#10000000b
	rdwr_data_to_SPI
	ld      r0,#00h
	rdwr_data_to_SPI
;  rst_CSE1
	ret



;**************************************************************************
;******************************** DRIVER **********************************       
;**************************************************************************

;****************************************
;*************** LEDs *******************
;****************************************

FlashLed::
;  spp     #0
;  srp     #0
	loop [r1] {
	   call    LedOn
	   delay   #40000
	   call    LedOff
	   delay   #40000
	   cpl     r0
	}
	ret

LedOff::
	cpl     r0
	and     P2DR,r0
;  clr_bit  P2DR,r0
	ret


LedOn::
	or      P2DR,r0
;  set_bit  P2DR,r0
	ret

				    
;****************************************
;******** Combinatore telefonico decadico
;****************************************
comb_tel_dec::
	ldw  rr8,#combtel_buffer
	loop [r10] {                    ; r10 numeri da comporre
	   ld      r11,(rr8)+           ; rr8 contiene i numeri
comb::
	   loop [r11] {
	      clr_bit P5DR,REL1       
	      delay   #20000            ; da calibrare
	      set_bit P5DR,REL1
	      delay   #20000            ; da calibrare
	   }
	   delay  #30000
	   delay  #30000
	   delay  #30000
	   delay  #30000
	}
	ret        



;****************************************
;************ Combinatore telefonico DTMF
;****************************************
comb_tel_dtmf::
	ld      r1,#20
	loop  [r1] {
		ld      r0,(rr8)+
		call    _8880_data_wr        
	}
	ret



;**************************************************************************
;**********  MT 8880 (Tranceiver DTMF / Call progress tone)  **************
;**************************************************************************

;***************************************
;********* init comb-tel
;***************************************
_8880_init::
	call    _8880_ctrl_rd
	ld      r0,#0000b
	call    _8880_ctrl_wr
	ld      r0,#0000b
	call    _8880_ctrl_wr
	ld      r0,#1000b
	call    _8880_ctrl_wr
	ld      r0,#0000b
	call    _8880_ctrl_wr
	ret

;***************************************
;********* write to MT8880 data register
;***************************************
;* input: r0 bit3..0
;*        bit 7,,4 must be 0
;***************************************
_8880_data_wr::
	pushu   P4DR
	ld      r1,#00000000b           ; assert data write end CS
	ld      P4DR,r1
	or      r1,#10000000b
	ld      P4DR,r1
	or      r0,r1
	ld      P4DR,r0
	nop
	nop
	and     r0,#01111111b
	ld      P4DR,r0
	nop
	popu    P4DR
	ret



;***************************************
;****** write to MT8880 control register
;***************************************
;* input: r0 bit3..0
;*        bit 7,,4 must be 0
;***************************************
_8880_ctrl_wr::
	pushu   P4DR
	ld      r1,#00100000b           ; assert data write end CS
	ld      P4DR,r1
	or      r1,#10000000b
	ld      P4DR,r1
	or      r0,r1
	ld      P4DR,r0
	and     r0,#01111111b
	ld      P4DR,r0
	delay   #20
	popu    P4DR
	ret




;***************************************
;************* read MT8880 data register
;***************************************
;* output: r0 bit3..0
;*
;***************************************
_8880_data_rd::
	pushu   P4DR
	ld      r1,#00011111b           ; assert data read CS
	ld      P4DR,r1
	or      r1,#10000000b
	ld      P4DR,r1
	ld      r3,P4DR
	ld      r0,#01111111b
	ld      P4DR,r0
	ld      r0,r3
	and     r0,#00001111b        
	delay   #20
	popu    P4DR
	ret




;***************************************
;********** read MT8880 control register
;***************************************
;* output: r0 bit3..0
;*
;***************************************
_8880_ctrl_rd::
	pushu   P4DR
	ld      r1,#00111111b           ; assert control write CS
	ld      P4DR,r1
	or      r1,#10000000b
	ld      P4DR,r1
	ld      r3,P4DR
	ld      r0,#01111111b
	ld      P4DR,r0
	ld      r0,r3           
	popu    P4DR
	ret


;****************************************
;********** put 8880 in POWER DOWN
;****************************************
_8880_pwd::
	push    P4DR
	ld      r1,P4DR
	and     r1,#00111111b           ;pongo O2  a 0 
	or      r1,#01000000b           ;pongo CS* a 1 
	ld      P4DR,r1
	pop     P4DR
	ret


;****************************************
;********** scan for call progress tones
;****************************************
_8880_scancp::
	ld      r0,#DTMFTONE
	call    _8880_ctrl_wr
	
	ret
	

;****************************************
;***************** Attivazione POWER DOWN
;****************************************
att_pwd::
	pushu   PPR
	spp     #P7D_PG
	ld      r0,P7DR
	or      r0,#00110000b           ; metto in PWD il 34118 e il 34119                         
	ld      P7DR,r0        
	popu    PPR
	ret



;****************************************
;************** Disattivazione POWER DOWN
;****************************************
disatt_pwd::
	pushu   PPR
	spp     #P7D_PG
	ld      r0,P7DR
	and     r0,#11001111b                         
	ld      P7DR,r0        
	popu    PPR
	ret



;****************************************
;****************** Attivazione VIVA VOCE
;****************************************
att_viva_voce::
	pushu   PPR
	spp     #P7D_PG
	ld      r0,P7DR
	or      r0,#00110000b           ; attiva MC34118 e MC34119
	ld      P7DR,r0
	popu    PPR
	ret


;****************************************
;*************** Disattivazione VIVA VOCE
;****************************************
disatt_viva_voce::
	pushu   PPR
	spp     #P7D_PG
	ld      r0,P7DR
	and     r0,#11001111b           ; disattiva MC34118 e MC34119
	ld      P7DR,r0
	popu    PPR
	ret

;**************************************************************************
;****************** Sezione messaggistica vocale **************************
;**************************************************************************
cue_message::
	pushuw     rr0
	set_bit    P5DR,VOICE_CUE
	delay      #50000
	clr_bit    P5DR,VOICE_CUE
	popuw      rr0
	ret

reset_message::
	pushuw     rr0
	clr_bit    P5DR,VOICE_ADDR
	delay      #50000
	set_bit    P5DR,VOICE_ADDR
	popuw      rr0
	ret


rec_message::
	pushu   PPR
	spp     #P7D_PG
	pushuw     rr0
	clr_bit    P7DR,RECN
	ldw        rr0,#40
	loopw [rr0] {
	   delay      #50000
	}
	set_bit    P7DR,RECN
;  delay      #50000
;  waitnobit  P7DR,#RECLEDN
	popuw      rr0
	popu    PPR
	ret

play_message::
	pushu   PPR
	spp     #P7D_PG
	pushuw     rr0
	clr_bit    P7DR,PLAYLN
	ldw        rr0,#10
	loopw [rr0] {
	   delay      #50000
	}
	call    cue_message
	ldw        rr0,#30
	loopw [rr0] {
	   delay      #50000
	}
	set_bit    P7DR,PLAYLN
;  delay      #50000
	popuw      rr0
	popu    PPR
	ret

;**************************************************************************
;***************************** Telecomando ********************************
;**************************************************************************

_frame_sample::
                                           ; time critical section begin
   waitnobit  P2DR,#REMOTE                 ; depends on int triggering
   ldw        rr0,#frame_buffer            ; loads the frame buffer
	ldw        (rr0),#0                     ; zero the buffer
	ld         r2,#2                        ; 2 samples of 6 bits
	loop [r2] {                             ; 
	   ld         r4,#0                     ; zero the shift register
	   ld         r3,#6                     ; 
	   loop [r3] {                          ; single bit sample loop
	      delay      #320                   ; wait 390uS (to calibrate)
         ifbit P2DR,#REMOTE                ;
            or         P5DR,#1
            ld         r5,#1               ; if level 1 r5 = 1
         } else {                          ;
            ld         r5,#0               ; else r5 = 0
         }                                 ;
         or         r4,r5                  ; add into shift register
	      rol        r4                     ; and shift left one bit
	      delay      #150                   ; wait 130uS (to calibrate)
         and        P5DR,#~1
	      waitnobit  P2DR,#REMOTE           ; wait for 0
	   }
      ld         (rr0),r4                  ; put shift reg into buffer
      incw       rr0                       ; increment buffer pointer
	}
                                           ; time critical section end
	ret

_remote_sample_old::
	waitbit    P2DR,#REMOTE
   delay      #80
   waitnobit  P2DR,#REMOTE
   delay      #5760                        ; first skip (to calibrate)
   
   call       _frame_sample                ; sample first frame
;   ld    r6,#3                             ; other four samples
;   loop  [r6] {
;      ldw        rr8,(frame_buffer)        ; save previous frame
;      waitbit    P2DR,#REMOTE
;      delay      #80
;      call       _frame_sample             ; sample next frame
;      delay      #4000
;      orw        (frame_buffer),rr8        ; defect-error logic
;   }
   ret


_remote_sample::
   ld      EIMR,#00000000b
   waitbit P2DR,#REMOTE

   spp     #T0D_PG                         ; Set timer0 data page
   or      T_FLAGR,#cp0
   or      T_TCR,#cen
   spp     #0

   waitnobit  P2DR,#REMOTE
   
   delay   #5800

   spp     #T0D_PG                         ; Set timer0 data page
   and     T_TCR,#~cen
   spp     #0

   delay   #4000
   ld      EIMR,#00000001b

   ret


;***********************************************************************
;************************** Programmazione Timer 0
;***********************************************************************

;****************************************
;*************** Sincronismi telecomando
;****************************************

T0_remote::        
	pushuw  RPP
	pushu   PPR
	srp     #(15*2)                         ; Set register bank F
	spp     #T0D_PG                         ; Set timer0 data page
   ld      t_tcr,  #00000000b              ; Set timer control reg
   ld      t_tmr,  #00000000b              ; Continuous/Retrigger mode
	ld      t_icr,  #00000000b              ; Set input control reg
   ld      t_idmr, #10000001b              ; Underflow interrupt
   ld      t_prsr,#3                       ; 1 uSec prescaler value
   ldw     t_reg0r,#400                    ; 400 uSec counter value 

	spp     #T0C_PG                         ; Set timer0 control page
   ld      t0_ivr,#T0_UNDERFLOW            ; Set int vector
   ld      t0_idcr,#00000001b              ; Set Timer T0 int level=1
	popu    PPR
	popuw   RPP
	ret
	
;****************************************
;**************** Sincronismi toni linea
;****************************************

T0_cptone::        
	pushuw  RPP
	pushu   PPR
	srp     #(15*2)                         ; Set register bank F
	spp     #T0D_PG                         ; Set timer0 data page
	sdm
	ld      t_tcr,  #00000000b              ; Set timer control reg
   ld      t_tmr,  #00000000b              ; Set timer mode reg
	ld      t_icr,  #00000000b              ; Set input control reg
	ld      t_idmr, #10000001b              ; Enable timer T0 interrupt
                                           ; on underflow event
	ld      t_prsr,#0                       ; Load prescaler value
	ldw     t_reg0r,#0                      ; Load capture0 value 
	ldw     t_reg1r,#0                      ; Load capture1 value 
	ldw     t_cmp0r,#0                      ; Load compare0 value 
	ldw     t_cmp1r,#0                      ; Load compare1 value

	spp     #T0C_PG                         ; Set timer0 control page
   ld      t0_ivr,#T0_UNDERFLOW+2            ; Set int vector
	ld      t0_idcr,#00000001b              ; Set Timer T0 int level=1
	popu    PPR
	popuw   RPP
	ret


;**************************************************************************
;*************************** Definizione dei dati *************************
;**************************************************************************
    
   .data
  ;.org    0

;//////////////////////// per usare emulatore /////////////////
   .org 200h
;//////////////////////////////////////////////////////////////

;****************************************
;***************** Buffers e flags vari
;****************************************
display_buffer::        .blkb   32              ; display buffer of 32 char
frame_buffer::          .blkw   2               ; format: 0xxxxxx00xxxxxx0
combtel_buffer::        .blkb   16              ; buffer of 32 numbers

;****************************************
;**************** Messaggi per il display
;****************************************

benvenuto::             .ascii  "Ciao ciao! :-)  (C) 97 A. Tuccia"
malvenuto::             .ascii  "Guarda i numeri:"
telesoccorso::          .ascii  "Il telesoccorso:"
telecomando::           .ascii  "Il telecomando: "
aiuto::                 .ascii  "Richiesta aiuto!"
copyright::             .ascii  "Copyright (c) 97NOVA - A. Tuccia"
msgtoni::               .ascii  "Toni della linea"

