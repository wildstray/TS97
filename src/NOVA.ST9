;************************************************************************** 
;*                                                                        *
;* FILE NAME:   Nova.st9                                                  *
;*                                                                        *
;* DESCRIPTION: Firmware for TELESOCCORSO                                 *
;*                                                                        *
;* CONTENTS:    * Simbols and numerical equivalences                      * 
;*              * Internal registers variables allocations                * 
;*              * ST9 configuration code                                  *
;*              * MAIN procedure                                          *
;*              * RTC procedure                                           *
;*              * HW related procedure                                    *
;*              * Interrupt service procedures                            *
;*              * Subroutines                                             *
;*              * Static data define                                      *
;*              * Data section define                                     *
;*                                                                        *
;* VERSION                : 0.5.0                                         *
;*                                                                        *
;*                                                                        *
;* LAST REVISION          : 18/06/97                                      *
;*                                                                        *
;* AUTHOR                 : Andrea Tuccia                                 *
;*                                                                        *
;**************************************************************************

                        .title          "TS firmware"
                        .pl             66      
                        .list           me      
                        .page

;**************************************************************************
;**************************** Include section *****************************
;**************************************************************************
.nlist             
.include    "..\include\system.inc"    ; System register
.include    "..\include\page_0.inc"    ; Page 0 register
.include    "..\include\io_port.inc"   ; I/O port register
.include    "..\include\mftimer.inc"   ; MF Timer register
.include    "..\include\ad_c.inc"      ; A/D converter register
.include    "..\include\sci.inc"       ; SCI register
.include    "..\include\bitmacro.inc"  ; BIT macros
.list
.include    "nova.mac"
.include    "menu.mac"



;**************************************************************************
;******************** Simbols and numerical equivalences ******************
;**************************************************************************

;***************************************
;********************* STACK Declaration
;***************************************
;SSTACK      := (15 * 16)               ; System stack address group C B
;USTACK      := (12 * 16)               ; User stack address group A
;//////////////////////// per usare emulatore///////////////////
SSTACK      := (13 * 16)                ; System stack address group C B
USTACK      := (11 * 16)                ; User stack address group A
;//////////////////////// per usare emulatore///////////////////


;***************************************
;********* text section absolute address
;***************************************
IVR_TABLE       = 0                     ; Start of interrupt vector table
SCI_IVR         = 040h                  ; Start SCI int vector
EXT_IVR         = 050h                  ; External interrupt base vector
MFT_IVR         = 0C0h                  ; Multifunction timer int vector
START           = 100h                  ; Start of C startup code
ROMDATA         = 3000h                 ; Static data start
ROMSIZE         = 4000h                 ; ROM size

;***************************************
;***************** constants declaration
;***************************************
on              = 1             
off             = 0            

;I2C BUS RELATED
E2_SLAVE     == 10100000b           ; EEPROM control byte
RTC_SLAVE    == 11010000b           ; Real Time Clock control byte

READ         == 1                   ; Read mode
WRITE        == 2                   ; Write mode
VERIFY       == 3                   ; Alternate read mode

TRANS_CTRL   == 1                   ; The slave control transferred
TRANS_ADDR   == 2                   ; The slave address transferred
TRANS_DWR    == 3                   ; The data has been transmitted
TRANS_DRD    == 4                   ; The data has been received

READING      == 1                   ; Slave is reading a byte.
VERIFYING    == 2                   ; Slave is reading the current byte.
WRITING      == 3                   ; Slave is programming a byte.
NO_ACK       == 4                   ; Slave has not acknowledged.

SLAVE_READY  == 80h                 ; Slave is ready for a new operation...


;DTMF/LINETONE DEFINES
DTMFAVLB        = 00000100b
DTMFINOUT       = 00000101b
DTMFTONE        = 00000110b
TONEHIZ         = 0
TONEDIAL        = 1
TONEPBX         = 2
TONEBUSY        = 3


;E2PROM MEMORY LOCATIONS
E2_CHECKSUM     = 0
E2_SERIAL       = 2
E2_REMOTE       = 6
E2_NUMERS       = 480
E2_EVENTS       = 608
E2_SIZE         = 2048


;MENUS/KEYPAD DECLARATION
FORWBACK        = 11
CONFIRM         = 12


;***************************************
;********************* I/O ports equates
;***************************************
;** P0X EQUATES ( P4X EMULATED )
RWN             = 00010000b
RS0             = 00100000b
CSN             = 01000000b
O2              = 10000000b

;** P1X EQUATES ( P7X EMULATED / SHIFTED LEFT 2 )
ENABLE          = 00000100b ;(00000001b)
PLAYLN          = 00001000b ;(00000010b)
RECN            = 00010000b ;(00000100b)
RECLEDN         = 00100000b ;(00001000b)
PD118           = 01000000b ;(00010000b)
PD119           = 10000000b ;(00100000b)

;** P2X EQUATES ( P2X EMULATED )
BACKLIGHT       = 00000001b
SDI             = 00000010b
SCK             = 00000100b
SDO             = 00001000b
DTMFCP          = 00010000b
LED1            = 00100000b
LED2            = 01000000b
REMOTE          = 10000000b

;** P3X EQUATES ( P3X EMULATED )
HOOK            = 00000001b
ALARM1          = 00000010b
ALARM2          = 00000100b
ALARM3          = 00001000b
PROG            = 00010000b
RESET           = 00100000b

;** P5X EQUATES ( P5X EMULATED )
MUTE            = 00000001b
REL1            = 00000010b
REL2            = 00000100b
RING            = 00001000b
CUE             = 00010000b
CONT            = 00100000b



;**************************************************************************
;**************** Internal register variable allocations ******************
;**************************************************************************

;**************
;* Bank C end D             
;**************
; Used for SSP


;**************
;******* Bank B             
;**************
; Used for USP


;**************
;******* Bank A             
;**************
;       := RR174 \
;       := RR172  | 
;       := RR170  |
;       := RR168  | Non usare con emulatore
;       := RR166  |
;       := RR164  |
;       := RR162  |
;       := RR160 /


;**************
;******* Bank 9     
;**************
;       := RR158 \
;       := RR156  |
;       := RR154  |
;       := RR152  | Non usare con emulatore                    
;       := RR150  | 
;       := RR148  |
;       := RR146  |
;       := RR144 /


;**************
;******* Bank 8             
;**************
DISP_F  := R142                         ; 
RING_C  := R141                         ;
RINGS   := R140                         ;
RTCFLAG := R139                         ;
COUNTCLK:= R138                         ;
SWITCH  := R137                         ;  
ALARM   := R136                         ; 
TONE_1  := R135                         ; 
TONE_0  := R134                         ;
DIGIT   := R133                         ;
PHONE   := R132                         ; 
REM_OK  := R131                         ;
CLOCK_C := R130                         ;
REM_C   := R129                         ; 
REM_F   := R128                         ; 
					

;**************
;******* Bank 7             
;**************
;       := RR126
;       := RR124
;       := RR122
;       := RR120
;       := RR118
;       := RR116 
;       := RR114 
;       := RR112 
					

;**************
;******* Bank 6             
;**************
MAXRING := R111                         ; Numero di squilli per rispondere
CYCLES  := R110                         ; Ripetizioni del cicli di allarme
REPT    := R109                         ; Ripetizioni del numero da chiamare
PAUSE   := R108                         ; Pausa tra una chiamata e l'altra
MAXRESP := R107                         ; Tempo massimo per una risposta
MAXCONF := R106                         ; Tempo massimo per confermare
PBX     := R105                         ; Ritardo dopo il primo zero per PBX
;       := RR104
;       := RR102
;       := RR100
;       := RR98  
;       := RR96  



;**************
;******* Bank 5                         
;**************
;       :=RR94
;       :=RR92
;       :=RR90
;       :=RR88
;       :=RR86
;       :=RR84
;       :=RR82
;       :=RR80



;**************
;******* Bank 4                         ; I2C bus manager
;**************
TOT_LENGHT := RR78
SLAVE_W    :=  R77                      ; Write slave control byte
SLAVE_R    :=  R76                      ; Read slave control byte
SLAVE_AH   :=  R75
SLAVE_AL   :=  R74
SLAVE_ABS  := RR74                      ; Absolute address in slave mem.
COUNTER    := RR72                      ; Bytes already transferred.
counter    :=  rr8
LENGHT     := RR70                      ; Number of bytes to be transfert.
lenght     :=  rr6
I2C_SLAVE  :=  R69                      ; Slave control byte.
SPI_STAT   :=  R68                      ; SPI transfer status.
SLAVE_STAT :=  R67                      ; Slave status.
SLAVE_OP   :=  R66                      ; Operation to do by the slave.
SLAVE_ADDR :=  R65                      ; Address in the slave memory.
TEMP       :=  R64                      ; Temporary data.
temp       :=  r0


;**************
;******* Bank 3                         ; Timer0 context registers
;**************
;       :=RR62                          ; Don't define!
;       :=RR60
;       :=RR58
;       :=RR56
;       :=RR54
;       :=RR52
;       :=RR50
;       :=RR48



;**************
;******* Bank 2                         ; WatchDog context registers
;**************
;       :=RR46                          ; Don't define!
;       :=RR44
;       :=RR42
;       :=RR40
;       :=RR38
;       :=RR36
;       :=RR34
;       :=RR32



;**************
;******* Bank 1                         ; Page #1 free run space
;**************
;       :=RR30                          
;       :=RR28                          
;       :=RR26                          
;       :=RR24
;       :=RR22
;       :=RR20
;       :=RR18
;       :=RR16



;**************************************************************************
;************************ TS INITIALIZATIONS CODE  ************************
;**************************************************************************
                        .text  


;***************************************
;**************** Interrupt vector table
;***************************************


   .org    IVR_TABLE
	.word   st9$entry                       ; Reset interrupt vector:Entry point
	.word   _trap_div0                      ; Divide by 0 interrupt service routine
	.word   _top_level_int                  ; Top Level interrupt service routine
	;***********************        
   .org    SCI_IVR
   .word   _SCI_it_s_rec_err               ; SCI receiver err int service
	.word   _SCI_9th_bit                    ; SCI 9th bit int service
   .word   _SCI_it_receive                 ; SCI RX int service
   .word   _SCI_it_transmit                ; SCI TX int service
	;***********************        
   .org    EXT_IVR                             
   .word   _A0_int                         ; Interrupt A0 ( Watchdog )
   .word   _A1_int                         ; Interrupt A1 ( 8880 IRQ )
   .word   _B0_int                         ; Interrupt B0 ( SPI int  )
   .word   _B1_int                         ; Interrupt B1 ( Remote   )
   .word   _C0_int                         ; Interrupt C0 ( External )
   .word   _C1_int                         ; Interrupt C1 ( External )
   .word   _D0_int                         ; Interrupt D0 ( External )
   .word   _D1_int                         ; Interrupt D1 ( External )
	;***********************        
   .org    MFT_IVR
   .word   _T0_int_0                       ; Multifunction timer interrupt
   .word   _T0_int_1                       ; Multifunction timer interrupt
   .word   _T0_int_2                       ; Multifunction timer interrupt
   .word   _T0_int_3                       ; Multifunction timer interrupt
	;***********************        



;***************************************
;************ Linker options entry point
;***************************************
                        .org    START
	;***********************        
st9$entryRS::                                   ; Entry point for Separate 
   sdm                                          ; Read Only Environment -iI
	;***********************        
st9$entryR_::                                   ; Entry point for 
   or      FLAGR,#10b                           ; Read Only Environment -I 
   jr      st9$entry_GO                         ; Set user flag:
                                                ; data (ROM) to bss (RAM) copy
	;***********************        
st9$entry_S::                                   ; Entry point for Separate
   sdm                                          ; Address Space -i
	;***********************        
st9$entry__::                                   ; Entry point for 
   and     FLAGR,#~10b                          ; Common Address Space
st9$entry_GO::                                  ;


;***************************************
;********* system register configuration 
;***************************************
	srp     #(14*2)                         ; Set register bank E

	spp     #0                              ; Init page pointer register
   ld      moder,#(sspm | uspm | div2m)    ; Set USP,SSP in int reg - Ck/2
   ld      usplr,#(USTACK)                 ; Init User stack pointer
   ld      ssplr,#(SSTACK)                 ; Init System stack pointer
   ld      cicr,#(gcenm | iamm | cplm)     ; CPL=7,enable counter,nested 
   and     flagr,#03h                      ; Clr flag register

   srp     #(15*2)                         ; Set bank register F

;***************************************
;**************** I/O port configuration
;***************************************
   spp     #P2C_PG                         ; Port 2 page
   ld      p2c2r,#11011110b                ;\
   ld      p2c1r,#01111100b                ; | Set port 2
   ld      p2c0r,#11011111b                ;/
   ;emulator board  ^     ^
	;***********************
   spp     #P3C_PG                         ; Port 3 page
   ld      p3c2r,#11111111b                ;\ 
   ld      p3c1r,#00000000b                ; | Set port 3
   ld      p3c0r,#11111111b                ;/
   ;***********************
   spp     #P4C_PG                         ; Port 4 page
	ld      p4c2r,#00000000b                ;\ 
	ld      p4c1r,#11110000b                ; | Set port 4
	ld      p4c0r,#00000000b                ;/
   ld      P4DR ,#00000000b                ;
	;***********************
   spp     #P5C_PG                         ; Port 5 page
   ld      p5c2r,#00000000b                ;\
   ld      p5c1r,#11110111b                ; | Set port 5
   ld      p5c0r,#00001000b                ;/
   ld      P5DR ,#00000000b                ;
	;***********************
   spp     #P7C_PG                         ; Port 7 page
	ld      p7c2r,#00100001b                ;\
	ld      p7c1r,#11011110b                ; | Set port 7
	ld      p7c0r,#00100011b                ;/
   ld      P7DR ,#00111111b                ;
   ;***********************


;***************************************
;*************** interupts configuration
;***************************************
   spp     #EXINT_PG                       ; External interrupts page  
   ld      eimr,#00000001b                 ; Unmask interrupts
   ld      eitr,#10001101b                 ; Set int triggers
   ld      eivr,#01010100b                 ; Set int_vect=5X / NMI
   ld      eiplr,#00101101b                ; Interrups priority (D-A-BC)
;  clr     nicr                            ; NMI TLI disabled   
;////////////////////// per usare emulatore ////////////////
   ld      nicr,#tlnmm                     ; NMI TLI enabled
;///////////////////////////////////////////////////////////
	ld      wcr,#01000000b                  ; Disable WatchDog
   clr     eipr                            ; Clear ext pending int.

;***************************************
;****************************** init SCI
;***************************************
	spp     #SCI1_PG                        ; Set SCI page register
	ld      s_brghr,#00                     ; Set baud_rate=19.200
	ld      s_imr,#00h                      ; Set int mask register
   ld      s_ivr,#SCI_IVR                  ; SCI interrupt vector
   ld      s_idpr,#00h                     ; Set interrupt priority=2
   ld      s_chcr,#(wl8 | sb10)            ; 8 data, 1 stop, no parity
   ld      s_ccr,#0                        ; 16X, internal baud rate
   clr     s_isr                           ; Clr pending interrupt
   ldw     s_brgr,#39                      ; Set baud_rate=19.200 (24Mhz)


;***************************************
;******************************* init WD
;***************************************
	spp     #WDT_PG                         ; Set Watch_dog timer page
   ld      wdtpr,#29                       ; 10 usec prescaler
   ldw     wdtr ,#5000                     ; 50 msec counter
   ld      wdtcr,#(stsp | 48)              ; Continuous, timer, start now

;***************************************
;****************************** init SPI
;***************************************
   spp     #SPI_PG                         ; Set SPI page
   ld      spicr,#(bms | SP_128)           ; I2C bus, 100KHz clock

                     
;***************************************
;******************** Serial line enable
;***************************************
;* Send a dummy char at power up
;* to set a correct state of TXempty flag.
;**************
;
;   srp     #0                              ; Set register bank 0
;   ;***********************
;   spp     #SCI1_PG                        ; Set SCI page register
;   ld      S_TXBR,#0AAh                    ; Trasmit dummy char
;   ;***********************
;   delay   #2000                           ; Delay to end tx
;   ;***********************                
;   and     S_ISR,#00000011b                ; Clear pending bit
;   ld      S_CCR,#80h                      ; Disable loop back mode
;   ld      s_idpr,#00001000b

;**************************************************************************
;************************** TS MAIN PROGRAM *******************************
;**************************************************************************
init::

	srp     #0                              ; Set register bank 0
	spp     #0                              ; Set Page 0

	call    display_init
	call    _8880_init
   call    _1420_init

   clr     EIPR

   ei

diagnose::
   print   line1, #message_diag
   call    rom_check
   if [r0 == #1]
   {
      ldw     rr4,#msg_romfail
   } else {
      ldw     rr4,#msg_romfail
   }
   print   line2, rr4
   sleep   #1000
   call    e2_check
   if [r0 == #1]
   {
      ldw     rr4,#msg_e2fail
   } else {
      ldw     rr4,#msg_e2ok
   }
   print   line2, rr4
   sleep   #1000
   call    rtc_check
   if [r0 == #1]
   {
      ldw     rr4,#msg_rtcfail
   } else {
      ldw     rr4,#msg_rtcok
   }
   print   line2, rr4
   sleep   #1000

   call    display_bufclr

   if [RTCFLAG != #0]
   {
      call    rtc_start
   }

   I2C READ,E2_SLAVE,#E2_REMOTE,#2
   ldw     rr0,#remote_buffer
   ldw     rr2,#i2c_buffer
   lddd    (rr0)+,(rr2)+
   lddd    (rr0)+,(rr2)+


idle::
   spp     #0
   ldw     rr0,#frame_buffer            ; loads the frame buffer
   ldw     (rr0),#0                     ; zero the buffer
   ld      ALARM,#0
   ld      HOOK,#0
   ld      SWITCH,#0
   ld      TONE_0,#255
   ld      RING_C,#0
   remote_ei
   _8880_di

   relay1  off
   relay2  off
   
   print   line1, #message_ready,#message_time

main::
   loop {
      ifbit SWITCH, #PROG
         jx       progr
      }
      if [ALARM > #0]
      {
         print    line2, #message_altrig
         jx       allarme
      }
      if [PHONE != #0]
      {
         jx       outgoing
      }
      ldw    rr0,(frame_buffer)
      ifw [[rr0 == (remote_buffer)] && [rr0 != #0]]
      {
         print    line2, #message_alrem
         jx       allarme
      }
      if [RTCFLAG != #0]
      {
         call    clock
      }
;      if [r3 >= MAXRING]
;      {
;         jx      allarme
;      }
;
   }


allarme::
   remote_di
   and     EIMR,#~11110000b

   print   line1, #message_alarm
;   sleep   #1000

   ifbit SWITCH, #RESET
     jx       annullamento
   }
   relay1  on
   sleep   #500

;   ld      r0,#DTMFINOUT
;   call    _8880_ctrl_wr

   ld      r0,#1001b
   call    _8880_ctrl_wr
   ld      r0,#0000b
   call    _8880_ctrl_wr

;   ldw     (combtel_buffer),#0A00h
;   call    combtel_dtmf
;   sleep   #1000

   ldw     rr0,#combtel_buffer
   ldw     rr2,#number
   ld      r4,#32
   loop [r4] {
      lddd (rr0)+,(rr2)+
	}
   call    combtel_dtmf
   sleep   #2000
   ifbit SWITCH, #RESET
     jx       annullamento
   }

;   ld      r0,#DTMFTONE
;   call    _8880_ctrl_wr
;   ld      r4,#20
;   loop [r4] {
;      call    _tone_sample
;      if [r0 == #TONEHIZ]
;      {
;         break
;      }
;      ifbit SWITCH, #RESET
;         jx       annullamento
;      }
;   }
;   if [r4 == #0]
;   {
;      inc   r6
;      jx    allarme
;   } else {

;      ld      r0,#DTMFTONE
;      call    _8880_ctrl_wr


   ld      r0,#1001b
   call    _8880_ctrl_wr
   ld      r0,#0000b
   call    _8880_ctrl_wr

;      ld      r4,#6
      ld      DIGIT,#0
      while [DIGIT != #5] {
         call    _1420_reset
         sleep   #100
         call    _1420_play
         sleep   #5000
         call    _1420_stop
         ifbit SWITCH, #RESET
            jx       annullamento
         }
      }
;  }
   ld      r0,#DTMFTONE
   call    _8880_ctrl_wr
   delay   #8000

;   and     P5DR ,#~00000001b

   loop {
      call    _tone_sample
      if [r0 == #TONEBUSY]
      {
         break
      }
      ifbit SWITCH, #RESET
         jx       annullamento
      }
   }
   relay1  off
   print   line1, #message_alarm, #message_ok
   sleep   #2000
   jx      idle
   
annullamento::
   print   line1, #message_alarm, #message_break
   sleep   #2000
   jx      idle


outgoing::
   print   line1, #message_cornetta, #message_alzata
   if [PHONE == #0]
   {
      print   line2, #message_abbassata
      sleep   #1000
      jx      idle
   }
   jx      outgoing


progr::
   _8880_ei
   remote_di

   print   line1, #message_progst, #message_tastibegin
   
   relay1  on
   relay2  on

   sleep   #1000
   
   ld      r0,#1001b
   call    _8880_ctrl_wr
   ld      r0,#0000b
   call    _8880_ctrl_wr

   ld      r2,#0
   ld      DIGIT,#0
	ld      r0,#DTMFINOUT
	call    _8880_ctrl_wr

   ld      r15,#7
   if [RTCFLAG == #0]
   {
      ld      r15,#5
   }
   .menu r15
      .display 0, menu_messaggi,     message_tastipr
      .display 1, menu_numeri,       message_tastipr
      .display 2, menu_telecomando,  message_tastipr
      .display 3, menu_imposta,      message_tastipr   
      .display 4, menu_oradata,      message_tastipr
      .display 5, menu_eventi,       message_tastipr   
      .action  0
                  call    menu_messages
      }
      .action  1
                  call    menu_numbers
      }
      .action  2
                  call    menu_remote
      }
      .action  3
                  call    menu_setup
      }
      .action  4
                  call    menu_clock
      }
      .action  5
                  call    menu_notavail
      }
   .endmenu
   relay1  off
   relay2  off
   print   line1, #message_fineprog1, #message_fineprog2
   sleep   #1000
   jx      idle


menu_notavail::
   pushu   r1 
   pushu   r2
   .menu
      print   line1, #sub_notavail1, #sub_notavail2
      .back
   .endmenu
   popu    r2
   popu    r1
   ret


menu_remote::
   pushu   r1 
   pushu   r2
   .menu #2
      .display 0, sub_remote1,       sub_remote2
      .display 1, sub_remcode1,,     remote
      .display 2, menu_preced1,      menu_preced2
      .action  0
                  print   line1, #sub_remhit1, #sub_remhit2
                  ldw     rr2,#frame_buffer
                  ldw     (rr2),#0
                  ldw     rr8,#200
                  remote_ei
                  loopw [rr8]
                  {
                     sleep   #100
                     ldw     rr2,(frame_buffer)
                     ifw [rr2 != #0]
                     {
                        break
                     }
                     ifnobit SWITCH, #PROG
                        break
                     }
                  }
                  remote_di
                  ifw [rr2 == #0]
                  {
                     print   line1, #sub_remfail1, #sub_remfail2
                     sleep   #1000
                  } else {
                     ldw     rr2,#i2c_buffer
                     ldw     rr4,#frame_buffer
                     lddd    (rr2)+,(rr4)+
                     lddd    (rr2)+,(rr4)+
                     I2C WRITE,E2_SLAVE,#E2_REMOTE,#2
                     print   line1, #sub_remok
                     call    remote
                     sleep   #2000
                  }
      }
      .action 1
                     call    remote_enter
      }
      .action 2
                     break
      }
   .endmenu
   popu    r2
   popu    r1
   ret


menu_messages::
   pushu   r1
   pushu   r2
   .menu #2
      .display 0, messaggi_record1,  messaggi_record2
      .display 1, messaggi_play1,    messaggi_play2
      .display 2, menu_preced1,      menu_preced2
      .action  0
                  call    _1420_reset
                  sleep   #200
                  print   line1, #sub_record1, #sub_record2
                  call    _1420_record
                  sleep   #5000
                  call    _1420_stop
                  print   line1, #sub_recend1, #sub_recend2
                  sleep   #1000
      }
      .action  1
                  call    _1420_reset
                  sleep   #200
                  print   line1, #sub_play1, #sub_play2
                  call    _1420_play
                  sleep   #5000
                  call    _1420_stop
                  print   line1, #sub_playend1, #sub_playend2
      }
      .action  2
                  break
      }
   .endmenu
   popu    r2
   popu    r1
   ret


menu_numbers::
   pushu   r1
   pushu   r2
   ld      r0,#1
   .menu #8
      .display 8, menu_preced1,      menu_preced2
      .action  8
         break
      }
      if [r1 == #CONFIRM]
      {
         call    number_enter
      }
      if [[r2 < #8] && [r2 != r0]]
      {
         ld      r0,r2
         call    number_read
         call    number_show
      }
   .endmenu
   popu    r2
   popu    r1
   ret


menu_setup::
   pushu   r1
   pushu   r2
   .menu #8
      .display 0, sub_T0_1,          sub_T0_2
      .display 1, sub_T1_1,          sub_T1_2
      .display 2, sub_T2_1,          sub_T2_2
      .display 3, sub_C0_1,          sub_C0_2
      .display 4, sub_C1_1,          sub_C1_2
      .display 5, sub_C2_1,          sub_C2_2
      .display 6, sub_selection1,    sub_selection2
      .display 7, sub_pbx1,          sub_pbx2
      .display 8, menu_preced1,      menu_preced2
      .action 0
                  call    enter
      }
      .action 1
                  call    enter
      }
      .action 2
                  call    enter
      }
      .action 3
                  call    enter
      }
      .action 4
                  call    enter
      }
      .action 5
                  call    enter
      }
      .action 8
                  break
      }
   .endmenu
   popu    r2
   popu    r1
   ret


menu_clock::
   pushu   r1
   pushu   r2
   .menu #2
      .display 0, sub_time1,,        clock
      .display 1, sub_date1,,        date
      .display 2, menu_preced1,      menu_preced2
      .action 0
                  call time_enter
      }
      .action 1
                  call date_enter
      }
      .action 2
                  break
      }
   .endmenu
   popu    r2
   popu    r1
   ret


;**************************************************************************
;********************** INTERRUPT SERVICE ROUTINES ************************
;**************************************************************************


;***************************************
;************************ T0 interrupt 0
;***************************************
_T0_int_0::
   push  PPR
   ;***********************                
   spp     #T0D_PG                         ; Enable Timer0 page
   and     T_FLAGR,#~(ouf | cp0 | cp1)     ; Clear Overflow/Underflow/Capture
   ;***********************
   dec     COUNTCLK                        ; When counter zeroes stop
   if [COUNTCLK == #0]
   {
      and      T_TCR,#~cen                 ; Stop Timer0
   } 
   ;***********************
   pop   PPR
	iret                                    


;***************************************
;************************ T0 interrupt 1
;***************************************
_T0_int_1::
	pushw   RPP                             ; Save RPP
	push    PPR                             ; Save PPR
   srp     #(3*2)                          ; Switch context
   ;***********************                
   spp     #T0D_PG                         ; Enable Timer0 page
   and     T_FLAGR,#~(ouf | cp0 | cp1)     ; Clear Overflow/Underflow/Capture
	spp     #0
   ;***********************
   inc     REM_F
   ifbit   P2DR,#REMOTE
      inc      REM_C
   }
   if [REM_C > #11]
   {
      clr      REM_F                       ; Clear remote flags
      clr      REM_C                       ; Clear remote flags
      clr      EIPR
      nop
      or       EIMR,#10000001b             ; Re-enable WD and REMOTE
      spp      #T0D_PG                     ; Enable Timer0 page
      and      T_TCR,#~cen                 ; Stop Timer0
      inc      REM_OK                      ; Increment validity flag
   }
   if [REM_F > #11]
   {
      clr      REM_F                       ; Clear remote flags
      clr      REM_C                       ; Clear remote flags
      clr      EIPR
      nop
      or       EIMR,#10000001b             ; Re-enable WD and REMOTE
      spp      #T0D_PG                     ; Enable Timer0 page
      and      T_TCR,#~cen                 ; Stop Timer0
   }
	;***********************                
	pop     PPR                             
	popw    RPP                             ; Restore context    
	iret                                    


;***************************************
;************************ T0 interrupt 2
;***************************************
_T0_int_2::
   push  PPR
   ;***********************                
   spp     #T0D_PG                         ; Enable Timer0 page
   and     T_FLAGR,#~(ouf | cp0 | cp1)     ; Clear Overflow/Underflow/Capture
	spp     #0
   ;***********************
   or    SLAVE_STAT,#SLAVE_READY           ; Write sequence is finished.
   pop   PPR
	iret                                    


;***************************************
;************************ T0 interrupt 3
;***************************************
_T0_int_3::
   iret




;***************************************
;**************************** _trap_div0
;***************************************
_trap_div0::                                    ; Divide by 0 interrupt service routine
	ret



;***************************************
;******************* Top level interrupt
;***************************************
_top_level_int::                                ; Top Level interrupt service routine
	iret



;***************************************
;****************** SCI errors interrupt
;***************************************
_SCI_it_s_rec_err::
	iret



;***************************************
;***************** SCI 9th bit interrupt
;***************************************
_SCI_9th_bit::
	iret



;***************************************
;**************** SCI TX empty interrupt
;***************************************
_SCI_it_transmit::
	iret



;***************************************
;********************* SCI RX interrupt
;***************************************
_SCI_it_receive::
	iret



;***************************************
;********************* WD timer int 50ms
;***************************************
_A0_int::
   push    PPR                             ; Save PPR
   pushw   RPP                             ; Save RPP
   srp     #(2*2)                          ; Switch context
   spp     #0
   ;clr     EIPR                            ; clear pending interrupts
   ;nop
   ;pushu   EIMR
   ;clr     EIMR                       
   and     EIPR,#~ipa0m                    ; clear pending bit
   ;***********************
   call    display_update                  ; resfresh display
	;***********************
   ifbit   P3DR,#ALARM1                    ; poll external alarms
      ld      ALARM,#ALARM1
   }
   ifbit   P3DR,#ALARM2
      ld      ALARM,#ALARM2
   }
   ifbit   P3DR,#ALARM3
      ld      ALARM,#ALARM3
   }
   ifbit   P3DR,#RESET                     ; poll user switches
      or      SWITCH,#RESET
   } else {
      and     SWITCH,#~RESET
   }
   ifbit   P3DR,#PROG
      or      SWITCH,#PROG
   } else {
      and     SWITCH,#~PROG
   }
   ifnobit   P5DR,#RING                    ; poll ring detector or
      if [r15 < #18]
      {
        inc      RING_C
      } else {
        inc      RINGS
        ld       RING_C,#0
      }
   } else {
      ifbit   P3DR,#HOOK                   ; phone hook status
         ld      PHONE,#1
      } else {
         ld      PHONE,#0
      }
   }
   ;***********************
   if [TONE_0 < #36]                       ; poll line-tone input to
   {                                       ; calculate a silence/tone ratio
      ld      r0,#200                    
      loop [r0] {
         ld      r1,P2DR
         and     r1,#DTMFCP
         if [r1 == #DTMFCP]
         {
            inc     TONE_1
            break
         }
         nop
         nop
      }
      inc     TONE_0
   }
   ;***********************
   ;spp     #0
   ;clr     EIPR                            ; WD generate spurious
   ;nop
   ;popu    EIMR                            ; re-enable all interrupts

   popw    RPP                             ; Restore context
   pop     PPR
	iret

;***************************************
;**************************** MT8880 IRQ
;***************************************
_A1_int::
   push    PPR
   pushw   RPP
   srp     #(3*2)
   spp     #0
   and     EIPR,#~ipa1m
   delay   #1000
   call    _8880_ctrl_rd
   ifbit   r0,#0101b
      call    _8880_data_rd
      ld      DIGIT,r0
	}
   delay   #1000
   ld      r0,#1100b
	call    _8880_ctrl_wr
   ld      r0,#0000b
	call    _8880_ctrl_wr
   popw    RPP
   pop     PPR
	iret


;***************************************
;************************* SPI Interrupt
;***************************************
_B0_int::
   push    PPR
   pushw   RPP
   srp     #(4*2)
   spp     #0
   if [SPI_STAT == #TRANS_DRD]
   {
      ld    temp,SPIDR         
      ld    i2c_buffer(counter),temp
      incw  counter
      decw  lenght
      if    [SETZ]
      {
         call  GEN_STOP   
         ld    SLAVE_STAT,#SLAVE_READY 
		} else {
         call  GEN_ACK 
         ld    SPI_STAT,#TRANS_DRD
         spp   #0
         ld    temp,#0FFH 
      } 
	} else {
      call  TEST_ACK          
      if [SLAVE_STAT == #NO_ACK]
      { 
         call  GEN_STOP      
         or    SLAVE_STAT,#SLAVE_READY   
		} else {
         switch [SPI_STAT] {
         case  #TRANS_CTRL:
            if [SLAVE_STAT == #VERIFYING]
            {
               ld    SPI_STAT,#TRANS_DRD
               spp   #0
               ld    temp,#0FFH 
				} else {
               ld    SPI_STAT,#TRANS_ADDR
					spp	#0
               ld    temp,SLAVE_ADDR
            }
         case  #TRANS_ADDR:
            if [SLAVE_OP == #READ]
            {
               call  GEN_START   
               ld    SPI_STAT,#TRANS_CTRL
               ld    temp,SLAVE_R
               ld    SLAVE_STAT,#VERIFYING  
				} else {
					spp	#0
               ld    SPI_STAT,#TRANS_DWR
               ld    temp,i2c_buffer(counter)
            } 
         case  #TRANS_DWR:
				spp	#0
            incw  counter
            decw  lenght  
            if    [CLZ]
            {
               ld    temp,i2c_buffer(counter)
            } else {  
               call  GEN_STOP
               or    SLAVE_STAT,#SLAVE_READY   
            } 
         }
      }
   } 
   ld    SPIDR,temp
   popw  RPP
   pop   PPR
	iret

;***************************************
;******** external or Software interrupt
;***************************************
_B1_int::
   iret

_C0_int::
   iret

_C1_int::
   iret

_D0_int::
   iret


_D1_int::
	push    PPR                             ; Save PPR
	pushw   RPP                             ; Save RPP
   srp     #(3*2)                          ; Switch context
   spp     #0
   and     EIPR,#~ipd1m                    ; clear pending bit
   delay   #30
   ifbit P2DR,#REMOTE                      ; Is here a level 1
      delay   #100
      ifbit P2DR,#REMOTE                   ; after 200 usec
 ;       and     EIMR,#~10000001b           ; Disable other interrupts
;        delay   #470
;        spp     #T0D_PG                    ; 
;        or      T_FLAGR,#(cp0 | ouf)       ; Trigger CP0 and OUF
;        or      T_TCR,#cen                 ; Start the timer
 ;       spp     #0
        call    _frame_sample
 ;       or      EIMR,#10000001b            ; Re-enable other interrupts
      }
   }
	popw    RPP                             ; Restore context    
	pop     PPR
	iret                                    


;**************************************************************************
;******************************** DISPLAY *********************************       
;**************************************************************************

				    
;***************************************
;************************** init display
;***************************************
display_init::
	ld      P4DR,#01001111b                 ; scrittura istruzioni
	;***********************    
	ld      r0,#00110000b                   ;\
	call    _display_nibble_wr              ; |
	delay   #4000                           ; | 
	ld      r0,#00110000b                   ; |
	call    _display_nibble_wr              ; | display software reset
	delay   #100                            ; | 
	ld      r0,#00110000b                   ; |
	call    _display_nibble_wr              ; |
	delay   #100                            ;/
	;***********************
	call    _display_ready
	ld      r0,#00100000b                   
	call    _display_nibble_wr              ; set interface to 4 bit
	;***********************
	call    _display_ready
	ld      r0,#00101000b                   ; set 2 lines, 5*7 font
	call    _display_write
	;***********************
	call    _display_ready
	ld      r0,#00001000b                   ; display off
	call    _display_write
	;***********************
	call    _display_ready
	ld      r0,#00001110b                   ; display on
	call    _display_write
	;***********************
	call    _display_ready
	ld      r0,#00000110b                   ; entry mode set
	call    _display_write
	ret




;***************************************
;************************ display update
;***************************************

display_return::
	call    _display_ready
   ld      P4DR,#01001111b                   ; set_dis_inst_wr_mode
   ld      r0,#00000010b                     ; return home
	call    _display_write
	ret

display_bufclr::
	ldw     rr8,#display_buffer
   ld      r10,#32                           ; loop write 32 char
	ld      r11,#00100000b
   loop [r10] {                              ; fill display buffer
      ld      (rr8)+,r11                     ; with spaces
	}
	ret

display_update:
	pushuw  rr0
	pushuw  rr2
	pushuw  rr8
	pushuw  rr10
	;***********************
	call    _display_ready
   ld      P4DR,#01001111b                   ; scrittura istruzioni
   ld      r0,#10000000b                     ; first line (set address)
	call    _display_write
	;***********************
	ldw     rr8,#display_buffer
	ld      r10,#16
   loop [r10] {                              ; loop 16 times (a line)
		call    _display_ready
      ld      P4DR,#01101111b                ; scrittura dati
		ld      r0,(rr8)+
		call    _display_write
	}
	;***********************
	call    _display_ready
   ld      P4DR,#01001111b                   ; scrittura istruzioni
   ld      r0,#11000000b                     ; second line (set address)
	call    _display_write
	;***********************
	ld      r10,#16
   loop [r10] {                              ; loop 16 times (a line)
		call    _display_ready
      ld      P4DR,#01101111b                ; scrittura dati
		ld      r0,(rr8)+
		call    _display_write
	}
	popuw   rr10
	popuw   rr8
	popuw   rr2
	popuw   rr0
	;*********************** 
	ret



;***************************************
;****************** display nibble write
;***************************************
_display_nibble_wr::
	pushu   PPR
	spp     #P7D_PG
	;***********************
   or      P7DR,#ENABLE            ; set E
	;*********************** 
	swap    r0
	and     r0,#00001111b
	ld      r2,P4DR
	and     r2,#11110000b             
	or      r0,r2
	ld      P4DR,r0                 ; write
	;***********************
   and     P7DR,#~ENABLE           ; reset E
	;***********************
	popu    PPR                 
	ret

;***************************************
;******************* display nibble read
;***************************************
_display_nibble_rd::
	pushu   PPR
	spp     #P7D_PG                 
	;***********************
   or      P7DR,#ENABLE            ; set E
	nop
   and     P7DR,#~ENABLE           ; reset E
	;***********************
	nop
	ld      r0,P4DR                 ; read
	and     r0,#00001111b
	swap    r0
	;*********************** 
	popu    PPR                 
	ret


;***************************************
;******************** display char write
;***************************************
_display_write::
	pushu   r0
	call    _display_nibble_wr
	popu    r0
	swap    r0
	call    _display_nibble_wr
	ret

;***************************************
;******************** display char write
;***************************************
_display_read::
	call    _display_nibble_rd
	ld      r1,r0
	call    _display_nibble_rd
	swap    r0
	or      r1,r0
	ld      r0,r1
	ret

;***************************************
;******************** is display ready ?
;***************************************
_display_ready:: 
	pushu   P4DR
	spp     #P7D_PG                 
	;***********************
	ld      P4DR,#01011111b         ; modo instruzioni & read
	;***********************
   ld     r2,#0FFh
   loop [r2] {
	   call    _display_read
      ifnobit r0,10000000b         ; controlla il BF
	      break
	   }
	}
	;***********************
	popu    P4DR
	ret


;**************************************************************************
;******************  Composizione numeri telefonici  **********************
;**************************************************************************
				    
;****************************************
;******** Combinatore telefonico decadico
;****************************************
combtel_decadic::
	ldw  rr8,#combtel_buffer
	loop [r10] {                    ; r10 numeri da comporre
	   ld      r11,(rr8)+           ; rr8 contiene i numeri
	   loop [r11] {
	      clr_bit P5DR,REL1       
         sleep   #48               ; da calibrare
	      set_bit P5DR,REL1
         sleep   #48               ; da calibrare
	   }
      sleep   #500
	}
	ret        


;****************************************
;************ Combinatore telefonico DTMF
;****************************************
combtel_dtmf::
   ldw     rr8,#combtel_buffer
   do {
      ld      r0,#1111b
      call    _8880_ctrl_wr
      ld      r0,#0000b
      call    _8880_ctrl_wr
      ld      r0,(rr8)+
		call    _8880_data_wr
      do {
         nop
         call    _8880_ctrl_rd
         nop
         ld      r1,r0
         and     r0,#00000010b
      } while [r0 == #0]
      sleep   #500
   } while [(rr8) != #0]
	ret


;**************************************************************************
;**********  MT 8880 (Tranceiver DTMF / Call progress tone)  **************
;**************************************************************************

;***************************************
;********* init comb-tel
;***************************************
_8880_init::
	call    _8880_ctrl_rd
	ld      r0,#0000b
	call    _8880_ctrl_wr
	ld      r0,#0000b
	call    _8880_ctrl_wr
	ld      r0,#1000b
	call    _8880_ctrl_wr
	ld      r0,#0000b
	call    _8880_ctrl_wr
	ret

;***************************************
;********* write to MT8880 data register
;***************************************
;* input: r0 bit3..0
;*        bit 7,,4 must be 0
;***************************************
_8880_data_wr::
	pushu   P4DR
	ld      r1,#00000000b           ; assert data write end CS
	ld      P4DR,r1
	or      r1,#10000000b
	ld      P4DR,r1
	or      r0,r1
	ld      P4DR,r0
	nop
	nop
	and     r0,#01111111b
	ld      P4DR,r0
	nop
	popu    P4DR
	ret



;***************************************
;****** write to MT8880 control register
;***************************************
;* input: r0 bit3..0
;*        bit 7,,4 must be 0
;***************************************
_8880_ctrl_wr::
	pushu   P4DR
	ld      r1,#00100000b           ; assert data write end CS
	ld      P4DR,r1
	or      r1,#10000000b
	ld      P4DR,r1
	or      r0,r1
	ld      P4DR,r0
	and     r0,#01111111b
	ld      P4DR,r0
	delay   #20
	popu    P4DR
	ret




;***************************************
;************* read MT8880 data register
;***************************************
;* output: r0 bit3..0
;*
;***************************************
_8880_data_rd::
	pushu   P4DR
	ld      r1,#00011111b           ; assert data read CS
	ld      P4DR,r1
	or      r1,#10000000b
	ld      P4DR,r1
	ld      r3,P4DR
	ld      r0,#01111111b
	ld      P4DR,r0
	ld      r0,r3
	and     r0,#00001111b        
	delay   #20
	popu    P4DR
	ret




;***************************************
;********** read MT8880 control register
;***************************************
;* output: r0 bit3..0
;*
;***************************************
_8880_ctrl_rd::
	pushu   P4DR
	ld      r1,#00111111b           ; assert control write CS
	ld      P4DR,r1
	or      r1,#10000000b
	ld      P4DR,r1
	ld      r3,P4DR
	ld      r0,#01111111b
	ld      P4DR,r0
	ld      r0,r3           
	popu    P4DR
	ret


;****************************************
;********** put 8880 in POWER DOWN
;****************************************
_8880_pwd::
	push    P4DR
	ld      r1,P4DR
   and     r1,#~(O2)               ; pongo O2  a 0 
   or      r1,#CSN                 ; pongo CS* a 1 
	ld      P4DR,r1
	pop     P4DR
	ret


;**************************************************************************
;****************** Attivazione/disattivazione vivavoce *******************
;**************************************************************************


;****************************************
;****************** Attivazione VIVA VOCE
;****************************************
vivavoce_on::
   pushu   PPR
	spp     #P7D_PG
   or      P7DR,#(PD118 | PD119)     ; attiva MC34118 e MC34119
   popu    PPR
   ret


;****************************************
;*************** Disattivazione VIVA VOCE
;****************************************
vivavoce_off::
   pushu   PPR
	spp     #P7D_PG
   and     P7DR,#~(PD118 | PD119)    ; disattiva MC34118 e MC34119
   popu    PPR
   ret

;****************************************
;*************** Disattivazione VIVA VOCE
;****************************************
mute_on::
   pushu   PPR
   or      P5DR,#MUTE                ; attiva muting MC34118
   popu    PPR
   ret

;****************************************
;*************** Disattivazione VIVA VOCE
;****************************************
mute_off::
   pushu   PPR
   and     P5DR,#~(MUTE)             ; disattiva muting MC34118
   popu    PPR
   ret


;**************************************************************************
;****************** Sezione messaggistica vocale **************************
;**************************************************************************

;****************************************
;************ Inizializza comandi ISD1420
;****************************************
_1420_init::
   pushu   PPR
   and     P5DR ,#~(CUE | CONT)      ; Non definitivo: solo per 1 messaggio
   popu    PPR
   ret

;****************************************
;************ Salta al prossimo messaggio
;****************************************
_1420_cue::
   pushu   PPR
   and         P5DR,#~CUE
   sleep       #100
   or          P5DR,#CUE
   popu    PPR
   ret

;****************************************
;***************** "Riavvolge" i messaggi
;****************************************
_1420_reset::
   pushu   PPR
   and         P5DR,#~CONT
   sleep       #100
   or          P5DR,#CONT
   popu    PPR
   ret

;****************************************
;******************** Inizia a registrare
;****************************************
_1420_record::
   pushu   PPR
   spp         #P7D_PG
   and         P7DR,#~RECN
   sleep       #100
   popu    PPR
   ret

;****************************************
;************ Inizia il play dei messaggi
;****************************************
_1420_play::
   pushu   PPR
   spp         #P7D_PG
   and         P7DR,#~PLAYLN
   sleep       #100
   popu    PPR
   ret

;****************************************
;************** Ferma il play o il record
;****************************************
_1420_stop::
   pushu   PPR
   spp         #P7D_PG
   or          P7DR,#(RECN | PLAYLN)
   sleep       #100
   popu    PPR
   ret


;**************************************************************************
;************************ Toni linea telefonica ***************************
;**************************************************************************

;****************************************
;************** Routine di riconoscimento
;****************************************

_tone_sample::
   spp     #0
;   ld      r0,#DTMFTONE
;   call    _8880_ctrl_wr

   ld      TONE_1,#0
   ld      TONE_0,#0
   sleep   #200
   while [TONE_0 < #36]
   {
     nop
   }

;   ld      r0,#DTMFINOUT
;   call    _8880_ctrl_wr
   ld r1,TONE_1
   if [[TONE_1 > #11] && [TONE_1 < #15]]     ; 11-15 
   {
     ld       r0,#TONEDIAL
   }
   if [[TONE_1 > #17] && [TONE_1 < #22]]     ; 17-22
   {
     ld       r0,#TONEBUSY
   }
   if [TONE_1 > #26]                         ; 26+
   {
     ld       r0,#TONEPBX
   }
   if [TONE_1 < #6]
   {
     ld       r0,#TONEHIZ
   }
	ret


;**************************************************************************
;***************************** Telecomando ********************************
;**************************************************************************


;****************************************
;****************** Programmazione Timer0
;****************************************
T0_remote::        
	pushuw  RPP
	pushu   PPR
	srp     #(15*2)                         ; Set register bank F
	spp     #T0D_PG                         ; Set timer0 data page
   ld      t_tcr,  #00000000b              ; Set timer control reg
   ld      t_tmr,  #00000000b              ; Continuous/Retrigger mode
	ld      t_icr,  #00000000b              ; Set input control reg
   ld      t_idmr, #10000001b              ; Underflow interrupt
   ld      t_prsr,#3                       ; 1 uSec prescaler value
   ldw     t_reg0r,#1150                   ; 1150 uSec counter value 

	spp     #T0C_PG                         ; Set timer0 control page
   ld      t0_ivr,#MFT_IVR+2               ; Set int vector
   ld      t0_idcr,#00000001b              ; Set Timer T0 int level=1
	popu    PPR
	popuw   RPP
	ret

;****************************************
;*************** Campionamento principale
;****************************************
_frame_sample::
                                           ; time critical section begin
;   waitbit    P2DR,#REMOTE                ; depends on int triggering
   waitnobit  P2DR,#REMOTE                 ; depends on int triggering
   ldw        rr0,#frame_buffer            ; loads the frame buffer
	ldw        (rr0),#0                     ; zero the buffer
	ld         r2,#2                        ; 2 samples of 6 bits
	loop [r2] {                             ; 
	   ld         r4,#0                     ; zero the shift register
	   ld         r3,#6                     ; 
	   loop [r3] {                          ; single bit sample loop
	      delay      #320                   ; wait 390uS (to calibrate)
         ifbit P2DR,#REMOTE                ;
            ld         r5,#1               ; if level 1 r5 = 1
         } else {                          ;
            ld         r5,#0               ; else r5 = 0
         }                                 ;
         or         r4,r5                  ; add into shift register
	      rol        r4                     ; and shift left one bit
	      delay      #150                   ; wait 130uS (to calibrate)
	      waitnobit  P2DR,#REMOTE           ; wait for 0
	   }
      ld         (rr0),r4                  ; put shift reg into buffer
      incw       rr0                       ; increment buffer pointer
	}
                                           ; time critical section end
	ret


;***********************************************************************
;************************** Gestione bus i2c ***************************
;***********************************************************************

;****************************************
;***************** Programmazione timer 0
;****************************************
T0_I2C::
	spp     #T0C_PG                         ; Set timer0 control page
   ld      T0_IVR,#MFT_IVR                 ; Set int vector
   ld      T0_IDCR,#00000001b              ; Set timer0 int level=x

	spp     #T0D_PG                         ; Set timer0 data page
   ld      T_TCR,  #00000000b              ; Set timer control reg
   ld      T_TMR,  #00000001b              ; Single/Retrigger mode
   ld      T_ICR,  #00000000b              ; Set input control reg
   ld      T_IDMR, #10000001b              ; Underflow interrupt
   ld      T_PRSR, #3                      ; 1 usec prescaler value
   ldw     T_REG0R,#5000                   ; 5 msec counter value
   decw    TOT_LENGHT
   while [CLZ] {
      addw    T_REG0R,#5000                ; 5 ms multiplied lenght
      decw    TOT_LENGHT
	}	
   or      T_TCR,  #cen                    ; Start the timer0
   ret

;****************************************
;*********** I2C bus operations on slaves
;****************************************
_i2c_transfer::
   spi_di
   ifw [SLAVE_ABS > #255]                 
   {                                     
      and     SLAVE_AL,#00000111b
      rol     SLAVE_AL
      or      SLAVE_W,SLAVE_AL
   }
   ld      SLAVE_ADDR,SLAVE_AH
   ld      SLAVE_R,SLAVE_W                 ; Slave read/write slave
   or      SLAVE_R,#1
   ldw     TOT_LENGHT,LENGHT               ; Save LENGHT before decrement.
   ldw     COUNTER,#0
   ifbit   SLAVE_STAT,#SLAVE_READY         ; Test if bus is free
      switch [SLAVE_OP] {
         case  #READ:
            call     GEN_START             ; SPI and interrupt init
            ld       SPI_STAT,#TRANS_CTRL  ; Slave address
            ld       SLAVE_STAT,#READING   ; Start read condition
            ld       SPIDR,SLAVE_W         ; write mode address
         case  #VERIFY:
            call     GEN_START             ; SPI and interrupt init
            ld       SPI_STAT,#TRANS_CTRL  ; Slave address
            ld       SLAVE_STAT,#VERIFYING ; Start verify condition
            ld       SPIDR,SLAVE_R         ; read mode address
         case  #WRITE:
            call     GEN_START             ; SPI and interrupt init
            ld       SPI_STAT,#TRANS_CTRL  ; Slave address
            ld       SLAVE_STAT,#WRITING   ; Start write condition
            ld       SPIDR,SLAVE_W         ; write mode address
      }
   }
   waitbit SLAVE_STAT,#SLAVE_READY
   delay   #2300
   ret

;****************************************
;************* START condition generation
;****************************************
GEN_START::
   pushu   PPR
   spp      #0                         ; SPI and ext. ints. in page 0.
   and      SPICR,#~spen               ; Disable SPI -> SDA, SCK in HZ
   and      P2DR,#~SDO                 ; Prepare "0" on output buffer of SDO.
   spp      #P2C_PG
   and      P2C0R,#~SDO                ; SDO line in output -> SDA line = "0".
   delay    #3                         ; Wait for start condition hold time.
   spp      #0
   or       SPICR,#spen                ; Enable SPI.
   nop
   spi_ei                              ; Enable SPI interrupt.
   spp      #P2C_PG
   or       P2C0R,#SDO                 ; SDO line in AF.
   popu     PPR
   ret

;****************************************
;************** STOP condition generation
;****************************************
GEN_STOP::
   pushu   PPR
   spp      #0
   spi_di                              ; Disable SPI interrupt.
   and      P2DR,#~SDO                 ; Prepare "0" on output buffer of SDO.
   spp      #P2C_PG
   and      P2C0R,#~SDO                ; SDO line in output -> SDA line = "0".
   spp      #0 
   and      SPICR,#~spen               ; Disable SPI -> SCK line = "1".
   delay    #3                         ; Wait for stop condition setup.
   spp      #P2C_PG
   or       P2C0R,#SDO                 ; SDO in AF -> SDA line = "1".
   popu     PPR
   ret

;****************************************
;***** ACK pulse generation and force SDA
;****************************************
GEN_ACK::
   pushu   PPR
   and      P2DR,#~SDO                 ; Prepare "0" on output buffer of SDO.
   spp      #P2C_PG                    
   and      P2C0R,#~SDO                ; SDO line in output -> SDA line = "0".
   spp      #0 
   and      SPICR,#~spen               ; Disable SPI -> SCK line = "1".
   delay    #3                         ; Wait for ACK hold time.
   or       SPICR,#spen                ; Enable SPI -> Force SDA and SCK low.
   spp      #P2C_PG
   or       P2C0R,#SDO                 ; SDO line in AF.
   popu     PPR
   ret

;****************************************
;*** ACK pulse generation and slave check
;****************************************
TEST_ACK::
   pushu   PPR
   and     SPICR,#~spen                ; Release SPI lines in disabling it.
   waitbit P2DR,#SCK                   ; Wait for SCK going high.
   ifbit   P2DR,#SDI                   ; Check if receiver has acknowledged.
      ld      SLAVE_STAT,#NO_ACK       ; If no ACK 
   } else {  
      delay   #3                       ; Wait for high period of the clock.
   } 
   or SPICR,#spen                      ; Enable SPI -> Force SDA low.
   popu     PPR
   ret


;**************************************************************************
;********************** Timer per conteggio tempi *************************
;**************************************************************************


;****************************************
;***************** Programmazione timer 0
;****************************************
T0_COUNTER::
	spp     #T0C_PG                         ; Set timer0 control page
   ld      T0_IVR,#MFT_IVR                 ; Set int vector
   ld      T0_IDCR,#00000001b              ; Set timer0 int level=x

	spp     #T0D_PG                         ; Set timer0 data page
   ld      T_TCR,  #00000000b              ; Set timer control reg
   ld      T_TMR,  #00000000b              ; Continuous/Retrigger mode
   ld      T_ICR,  #00000000b              ; Set input control reg
   ld      T_IDMR, #10000001b              ; Underflow interrupt
   ld      T_PRSR, #30                     ; 200 usec prescaler value
   ldw     T_REG0R,#50000                  ; 1000 msec counter value
   or      T_TCR,  #cen                    ; Start the timer0
   ret

;****************************************
;************** Ritardo di x millisecondi
;****************************************
_msleep::
   pushuw  rr2
   loopw [rr0] {
      ldw   rr2,#430
      loopw [rr2] {
         nop
      }
   }
   popuw   rr2
   ret

;**************************************************************************
;***************************** Routines varie *****************************
;**************************************************************************

clock::
   pushu   r0
   pushu   r1
   pushu   r2
   pushu   r3
   pushu   r4
   pushu   r5
   pushu   r8
   dec     CLOCK_C
   if [SETZ]
   {
      call    rtc_read
      ld      CLOCK_C,#200
   }
   di
   blank   line2
   ldw     rr6,#line2+12
   ldw     rr4,#rtc_buffer
   ld      r8,#58
   ld      r3,#3
   loop [r3]
   {
      ld    r0,(rr4)
      incw  rr4
      byte2bcd r0,r2,r1
      bcd2ascii r1,r1
      bcd2ascii r2,r2
      ld    -(rr6),r1
      ld    -(rr6),r2
      if [r3 != #1]
      {
         ld    -(rr6),r8
      }
   }
   ei
   popu    r8
   popu    r5
   popu    r4
   popu    r3
   popu    r2
   popu    r1
   popu    r0
   ret


date::
   pushu   r0
   pushu   r1
   pushu   r2
   pushu   r3
   pushu   r4
   pushu   r5
   pushu   r8
   call    rtc_read
   di
   blank   line2
   ldw     rr6,#line2+13
   ldw     rr4,#rtc_buffer+4
   ld      r8,#47
   ld      r3,#4
   loop [r3]
   {
      if [r3 == #2]
      {
         ldw   rr4,#rtc_buffer+5
      }
      if [r3 == #3]
      {
         ldw   rr4,#rtc_buffer+8
      }
      ld    r0,(rr4)
      incw  rr4
      byte2bcd r0,r2,r1
      bcd2ascii r1,r1
      bcd2ascii r2,r2
      ld    -(rr6),r1
      ld    -(rr6),r2
      if [[r3 == #2] || [r3 == #3]]
      {
         ld    -(rr6),r8
      }
   }
   ei
   popu    r8
   popu    r5
   popu    r4
   popu    r3
   popu    r2
   popu    r1
   popu    r0
   ret


remote::
   pushu   r0
   pushu   r1
   pushu   r2
   pushu   r3
   pushu   r4
   pushu   r5
   pushu   r6
   pushu   r8
   di
   blank   line2
   ldw     rr6,#line2+2
   ldw     rr4,(remote_buffer)
   ld      r1,#16
   loop [r1] 
   {
      if [[r1 != #16] && [r1 != #8] && [r1 != #9] && [r1 != #1]]
      {
         ld      r2,#48
         ifbitw  rr4,#1000000000000000b
            ld      r2,#49
         }
         ld      (rr6)+,r2
      }
      rlcw    rr4
   }
   ei
   popu    r8
   popu    r6
   popu    r5
   popu    r4
   popu    r3
   popu    r2
   popu    r1
   popu    r0
   ret


rtc_read::
   pushu   r0
   pushu   r1
   pushu   r2
   pushu   r3
   pushu   r4
   I2C     READ,RTC_SLAVE,#0,#8
   ldw     rr0,#i2c_buffer
   ldw     rr2,#rtc_buffer
   ld      r4,#8
   ld      r4,#10
   loop [r4] {
      lddd    (rr2)+,(rr0)+
   }
   popu    r4
   popu    r3
   popu    r2
   popu    r1
   popu    r0
   ret


rtc_write::
   pushu   r0
   pushu   r1
   pushu   r2
   pushu   r3
   pushu   r4
   ldw     rr0,#i2c_buffer
   ldw     rr2,#rtc_buffer
   ld      r4,#8
   loop [r4] {
      lddd    (rr0)+,(rr2)+
   }
   I2C     WRITE,RTC_SLAVE,#0,#8
   popu    r4
   popu    r3
   popu    r2
   popu    r1
   popu    r0
   ret


rtc_start::
   I2C READ,RTC_SLAVE,#0,#1
   or  (i2c_buffer),#80h
   I2C WRITE,RTC_SLAVE,#0,#1
   and (i2c_buffer),#~80h
   I2C WRITE,RTC_SLAVE,#0,#1
   ret

rom_check::
   ld r0,#1
   ret


e2_check::
   ret


e2_update::
   ret


rtc_check::
   ld      (i2c_buffer),#0AAh
   I2C WRITE,RTC_SLAVE,#8,#1
   ld      (i2c_buffer),#0
   I2C READ,RTC_SLAVE,#8,#1
   ld      RTCFLAG,#0
   ld      r0,#1
   if [(i2c_buffer) == #0AAh]
   {
      ld      r0,#0
      ld      RTCFLAG,#1
   }
   ret


number_read::
   pushu   r1
   pushu   r2
   zero    number,#16
   ldw     rr2,#8
   mul     rr2,r0
   addw    rr2,#E2_NUMERS
   I2C READ, E2_SLAVE, rr2, #8
   if [(i2c_buffer) != #0]
   {
     ldw     rr12,#0
     ldw     rr4,#0
     loop 
     {
        ld      r3,i2c_buffer(rr12)
        incw    rr12
        byte2bcd r3,r1,r2
        ld      number(rr4),r1
        incw    rr4
        ld      number(rr4),r2
        incw    rr4
        if [[r1 == #0] || [r2 == #0]]
        {
           break
        }
     }
   }
   popu    r2
   popu    r1
   ret


number_write::
   pushu   r1
   pushu   r2
   zero    i2c_buffer,#8
   ldw     rr6,#0
   ldw     rr4,#0
   loop
   {
      ld      r1,number(rr4)
      incw    rr4
      ld      r2,number(rr4)
      incw    rr4
      bcd2byte r1,r2,r3
      ld      i2c_buffer(rr6),r3
      incw    rr6
      if [[r1 == #0] || [r2 == #0]]
      {
         break
      }
   }
   ldw     rr2,#8
   mul     rr2,r0
   addw    rr2,#E2_NUMERS
   I2C WRITE, E2_SLAVE, rr2, #8
   popu    r2
   popu    r1
   ret


number_show::
   pushu   r0
   pushu   r1
   call    display_bufclr
   print   line1, #numeri_begin
   ldw     rr4,#15
   loopw [rr4] {
      ld      r1,line1(rr4)
      if [r1 == #23h]
      {
         ld    r1,r0
         inc   r1
         bcd2ascii r1,r1
         ld    line1(rr4),r1
      }
   }
   ldw     rr6,#line2
   ldw     rr10,#number
   loop 
   {
      ld      r1,(rr10)+
      bcd2ascii r1,r9
      ld      (rr6)+,r9
      if [r1 == #0]
      {
         ld      r9,#32
         ld      -(rr6),r9
         break
      }
   }
   popu    r1
   popu    r0
   ret


number_enter::
   pushu   r0
   pushu   r1
   call    number_read
   call    display_bufclr
   print   line1, #numeri_begin
   ldw     rr4,#15
   loopw [rr4] {
      ld      r1,line1(rr4)
      if [r1 == #23h]
      {
         ld    r1,r0
         inc   r1
         bcd2ascii r1,r1
         ld    line1(rr4),r1
      }
   }
   ld      r8,#0
   ldw     rr6,#line2
   ldw     rr10,#number
   if [(number) != #0]
   {
      loop
      {
         ld      r1,(rr10)+
         bcd2ascii r1,r9
         ld      (rr6)+,r9
         inc     r8
         if [r1 == #0]
         {
            ld      r9,#95
            ld      -(rr6),r9
            ld      -(rr10),r1
            dec     r8
            break
         }
      }
   } else {
      ld      r1,#95
      ld      (rr6),r1
   }
   .input 0,15,32
   .endinput
   call    number_write
   popu    r1
   popu    r0
   ret


time_enter::
   pushu   r0
   pushu   r1
   pushu   r2
   pushu   r3
   call    rtc_read
   ldw     rr4,#rtc_buffer
   ldw     rr10,#time_buffer+6
   ld      r3,#3
   loop [r3] {
      ld      r0,(rr4)
      incw    rr4
      byte2bcd r0,r2,r1
      ld      -(rr10),r1
      ld      -(rr10),r2
   }
   ldw     rr6,#line2
   ldw     rr10,#time_buffer
   ld      r8,#4
   addw    rr6,#4
   ld      r9,#95
   ld      (rr6),r9
   .input  4,11,48
      .maxval   4,2
      .maxval   5,3,2
      .maxval   7,5
      .maxval   10,5
      .break    6,58
      .break    9,58
   .endinput
   ldw     rr4,#rtc_buffer
   ldw     rr10,#time_buffer+6
   ld      r3,#3
   loop [r3] {
      decw    rr10
      ld      r1,(rr10)
      decw    rr10
      ld      r2,(rr10)
      dtmf2bcd r1,r1
      dtmf2bcd r2,r2
      bcd2byte r2,r1,r0
      ld      (rr4),r0
      incw    rr4
   }
   call    rtc_write
   popu    r3
   popu    r2
   popu    r1
   popu    r0
   ret


date_enter::
   pushu   r0
   pushu   r1
   pushu   r2
   pushu   r3
   call    rtc_read
   ldw     rr4,#rtc_buffer+4
   ldw     rr10,#date_buffer+6
   ld      r3,#4
   loop [r3] {
      if [r3 == #1]
      {
         ldw     rr10,#date_buffer+6
         incw    rr4 
      }
      if [r3 == #3]
      {
         ldw     rr10,#date_buffer+4
      }
      ld      r0,(rr4)
      incw    rr4
      byte2bcd r0,r2,r1
      ld      -(rr10),r1
      ld      -(rr10),r2
   }
   ldw     rr6,#line2
   ldw     rr10,#date_buffer
   ld      r8,#3
   addw    rr6,#3
   ld      r9,#95
   ld      (rr6),r9
   .input  3,12,48
      .maxval   3,3
      .minval   4,1,0
      .maxval   4,1,3
      .maxval   6,1
      .minval   7,1,0
      .maxval   7,2,1
      .maxval   9,2
      .maxval  10,0,2
      .minval   9,1
      .minval  10,9,1
      .break    5,47
      .break    8,47
   .endinput        
   call    rtc_read
   ldw     rr4,#rtc_buffer+4
   ldw     rr10,#date_buffer+8
   ld      r3,#4
   loop [r3] {
      if [r3 == #1]
      {
         ldw     rr10,#date_buffer+6
         incw    rr4 
      }
      if [r3 == #3]
      {
         ldw     rr10,#date_buffer+4
      }
      decw    rr10
      ld      r1,(rr10)
      decw    rr10
      ld      r2,(rr10)
      dtmf2bcd r1,r1
      dtmf2bcd r2,r2
      bcd2byte r2,r1,r0
      ld      (rr4),r0
      incw    rr4
   }
   call    rtc_write
   popu    r3
   popu    r2
   popu    r1
   popu    r0
   ret


remote_enter::
   pushu   r0
   pushu   r1
   pushu   r2
   pushu   r3
   ldw     rr6,#remcode_buffer
   ldw     rr4,(remote_buffer)
   ld      r1,#16
   loop [r1] 
   {
      if [[r1 != #16] && [r1 != #8] && [r1 != #9] && [r1 != #1]]
      {
         ld      r2,#0
         ifbitw  rr4,#1000000000000000b
            ld      r2,#1
         }
         ld      (rr6)+,r2
      }
      rlcw    rr4
   }
   ldw     rr6,#line2
   ldw     rr10,#remcode_buffer
   ld      r8,#2
   addw    rr6,#2
   ld      r9,#95
   ld      (rr6),r9
   .input  2,13,48
      .maxval   2,1
      .maxval   3,1
      .maxval   4,1
      .maxval   5,1
      .maxval   6,1
      .maxval   7,1
      .maxval   8,1
      .maxval   9,1
      .maxval  10,1
      .maxval  11,1
      .maxval  12,1
      .maxval  13,1
   .endinput
   ldw     rr6,#remcode_buffer
   ldw     rr4,#0
   ld      r1,#16
   loop [r1]
   {
      rlcw    rr4
      andw    rr4,#~1
      if [[r1 != #16] && [r1 != #8] && [r1 != #9] && [r1 != #1]]
      {
         ld      r2,(rr6)
         incw    rr6
         if [r2 == #1]
         {
             orw     rr4,#1   
         }
      }
   }
   ldw     (remote_buffer),rr4
   ldw     rr2,#i2c_buffer
   ldw     rr4,#remote_buffer
   lddd    (rr2)+,(rr4)+
   lddd    (rr2)+,(rr4)+
   I2C WRITE,E2_SLAVE,#E2_REMOTE,#2
   popu    r3
   popu    r2
   popu    r1
   popu    r0
   ret


enter::
   pushu   r0
   pushu   r1
   pushu   r2

      ldw     rr6,#line2+4
      ldw     rr10,#tempinput
      ld      r8,#4
      ld      r9,#95
      ld      (rr6),r9
      .input  4,4,32
         .minval 4,1
      .endinput

   popu    r2
   popu    r1
   popu    r0
   ret


;**************************************************************************
;************************** Dati statici in rom ***************************
;**************************************************************************

;                        .org    ROMDATA
id::                    .ascii  "FW 0.5 Tuccia (C) 1997"

;****************************************
;**************** Messaggi per il display
;****************************************

message_open::          .ascii  "    PT117/96    "
message_name::          .ascii  "Nova Elettra srl"
message_diagok::        .ascii  "Hard Ok  Soft Ok"
message_diagfail::      .ascii  "MALFUNZIONAMENTO"
message_ok::            .ascii  "   INOLTRATO    "
message_ready::         .ascii  "Telesoccorso DGE"
message_time::          .ascii  "    ##:##:##    "
message_alarm::         .ascii  "Allarme in corso"
message_alrem::         .ascii  "da telecomando  "
message_altrig::        .ascii  "da pulsante     "
message_altime::        .ascii  "per fine tempo  "
message_break::         .ascii  "   ANNULLATO    "
message_attendere::     .ascii  "attendere prego."

message_diag::          .ascii  "  AUTODIAGNOSI  "
msg_romfail::           .ascii  "Checksum ROM: NO"
msg_romok::             .ascii  "Checksum ROM: Ok"
msg_e2fail::            .ascii  "Checksum E2:  NO"
msg_e2ok::              .ascii  "Checksum E2:  Ok"
msg_rtcfail::           .ascii  "Checksum RTC: NO"
msg_rtcok::             .ascii  "Checksum RTC: Ok"
msg_rtcno1::            .ascii  "Registro eventi "
msg_rtcno2::            .ascii  " non presente.  "
msg_8880fail::          .ascii  "MT8880 Regs:  NO"
msg_8880ok::            .ascii  "MT8880 Regs:  Ok"

message_call::          .ascii  "Composizione del"
message_noresp::        .ascii  "  Non risponde  "
message_resp::          .ascii  "Risponde il num."
                                   
message_progst::        .ascii  " Programmazione "
message_tastipr::       .ascii  " *~  # Conferma "
message_tastibegin::    .ascii  "Alzare cornetta!"
message_tastiend1::     .ascii  "    Alla fine   "
message_tastiend2::     .ascii  "  riagganciare. "
message_fineprog1::     .ascii  " Programmazione "
message_fineprog2::     .ascii  "   terminata.   "
menu_messaggi::         .ascii  "    Messaggi   ~"
menu_numeri::           .ascii  "  Numeri Tel. ~"
menu_telecomando::      .ascii  " Telecomando  ~"
menu_imposta::          .ascii  " Impostazioni ~"
menu_oradata::          .ascii  "  Ora / Data  ~"
menu_eventi::           .ascii  "Registro eventi"
sub_notavail1::         .ascii  "Non disponibile!"
sub_notavail2::         .ascii  " *             "

messaggi_record1::      .ascii  "    Registra   ~"
messaggi_record2::      .ascii  " *~   # Inizia  "
messaggi_play1::        .ascii  "  Riascolta   ~"
messaggi_play2::        .ascii  " *~   # Inizia  "
sub_record1::           .ascii  "  Parlare nel   "
sub_record2::           .ascii  " microfono....  "
sub_recend1::           .ascii  "   Messaggio    "
sub_recend2::           .ascii  "  registrato.   "
sub_play1::             .ascii  "   Ascoltare    "
sub_play2::             .ascii  " il messaggio..."
sub_playend1::          .ascii  "     Fine       "
sub_playend2::          .ascii  "   messaggio.   "
messaggi_alarm::        .ascii  "Mess. Allarme #~"

sub_numeri1::           .ascii  "   Numeri Tel.  "
sub_numeri2::           .ascii  " *  # Conferma "

sub_remote1::           .ascii  "   Aquisisci   ~"
sub_remote2::           .ascii  " *~    # Inizia "
sub_remcode1::          .ascii  " Imposta man. ~"
sub_remcode2::          .ascii  "  ############  "

sub_remhit1::           .ascii  "Premere il tasto"
sub_remhit2::           .ascii  "del telecomando!"
sub_remok::             .ascii  "Codice aquisito:"
sub_remfail1::          .ascii  "  Telecomando   "
sub_remfail2::          .ascii  " NON AQUISITO!  "

sub_time1::             .ascii  "  Cambio ORA:  ~"
sub_time2::             .ascii  "    ##:##:##    " 
sub_date1::             .ascii  "  Cambio DATA: ~"
sub_date2::             .ascii  "   ##/##/####   " 

sub_T0_1::              .ascii  "Pausa tra telef:" 
sub_T0_2::              .ascii  "   ## secondi   "  
sub_T1_1::              .ascii  "Tempo risposta: " 
sub_T1_2::              .ascii  "   ## secondi   "  
sub_T2_1::              .ascii  "Tempo conferma: " 
sub_T2_2::              .ascii  "   ## secondi   "  
sub_C0_1::              .ascii  "Ripetiz. numeri:" 
sub_C0_2::              .ascii  "    # volte     "  
sub_C1_1::              .ascii  "Ripetiz. ciclo: " 
sub_C1_2::              .ascii  "    # volte     "  
sub_C2_1::              .ascii  "Risposta dopo:  " 
sub_C2_2::              .ascii  "    # squilli   "  
sub_pbx1::              .ascii  "Collegato a PBX:"
sub_pbx2::              .ascii  "       ##       "
sub_selection1::        .ascii  "Selez. decadica:"
sub_selection2::        .ascii  "       ##       "

sub_tempi1::            .ascii  "    Tempi     ~"
sub_tempi2::            .ascii  " *             "
sub_riservato1::        .ascii  "  Riservato    "
sub_riservato2::        .ascii  " *             "
numeri_begin::          .ascii  "   Numero  #:   "
numeri_absent::         .ascii  "Non programmato!"
menu_preced1::          .ascii  "   Ritorna al   "
menu_preced2::          .ascii  "menu precedente."

message_cornetta::      .ascii  "Cornetta telef. "
message_abbassata::     .ascii  "   ABBASSATA    "
message_alzata::        .ascii  "     ALZATA     "

malvenuto::             .ascii  "Guarda i numeri:"
telesoccorso::          .ascii  "Il telesoccorso:"
telecomando::           .ascii  "Il telecomando: "

msgtony::               .ascii  "Linea telefonica"
msgoccupato::           .ascii  "    OCCUPATA    "
msglibero::             .ascii  "     LIBERA     "
msgpbx::                .ascii  "   PBX LIBERO   "
msghiz::                .ascii  " ALTA IMPEDENZA "



;**************************************************************************
;************************* Fine ROM - Checksum ****************************
;**************************************************************************

;                        .org    (ROMSIZE - 8)
pattern::               .byte   055h,0AAh
serial::                .byte   1,0,0,2
checksum::              .byte   0,0


;**************************************************************************
;****************** Definizione dei dati dinamici in RAM ******************
;**************************************************************************
    
                        .data
;                        .org    0

;//////////////////////// per usare emulatore /////////////////
                        .org 200h
;//////////////////////////////////////////////////////////////

frame_buffer::          .blkb   2               ; format: 0xxxxxx00xxxxxx0
remote_buffer::         .blkb   2               ; format: 0xxxxxx00xxxxxx0

combtel_buffer::        .blkb   16              ; buffer of 16 numbers
number::                .blkb   16              ; current telefonic number

i2c_buffer::            .blkb   8               ; buffer for i2c bus

rtc_buffer::            .blkb   8               ; rtc time/date buffer

time_buffer::           .blkb   6               ; entered time (bcd)
date_buffer::           .blkb   8               ; entered date (bcd)
remcode_buffer::        .blkb   12              ; remote code buffer (bcd)

display_buffer::
line1::                 .blkb   16              ; display buffer of 32 char
line2::                 .blkb   16

tempinput::             .blkb   4
